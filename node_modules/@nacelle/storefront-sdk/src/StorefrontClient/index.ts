import { OperationResult } from '@urql/core';

import {
  ContentCollection,
  Content,
  NavigationGroup,
  ProductCollection,
  Product,
  SpaceProperties,
  ContentEdge,
  ProductEdge,
  ProductCollectionEdge,
  ContentCollectionEdge,
} from '../types/graphql-generated';

import {
  FetchMethodParams,
  FetchCollectionMethodParams,
  FetchContentMethodParams,
  FetchCollectionEntriesMethodParams,
  NavigationParams,
  QueryParams,
} from '../types/parameters';

import StorefrontConnector from '../StorefrontConnector';
import SubscriptionConnector, { Observable } from '../SubscriptionConnector';

export interface StorefrontParams {
  token: string;
  storefrontEndpoint: string;
  currencyCode?: string;
  locale?: string;
  connector?: StorefrontConnector;
  onDataError?: OnDataError;
  debugMode?: boolean;
  subscriptionEndpoint?: string;
  subscriptionToken?: string;
  subscriptionSpaceId?: string;
}

export interface StorefrontConfig extends StorefrontParams {
  afterSubscriptions: AfterSubscription[];
}

export interface StorefrontInstance {
  after: (
    method: string,
    callback: <T>(responseObj: T) => Promise<T> | T
  ) => void;
  content: (
    contentParams?: FetchContentMethodParams
  ) => Promise<Array<Content | ContentEdge>>;
  contentCollections: (
    contentCollectionsParams?: FetchCollectionMethodParams
  ) => Promise<Array<ContentCollection | ContentCollectionEdge>>;
  getConfig: () => StorefrontConfig;
  navigation: (params?: NavigationParams) => Promise<NavigationGroup[]>;
  products: (
    productsParams?: FetchMethodParams
  ) => Promise<Array<Product | ProductEdge>>;
  productCollections: (
    productCollectionsParams?: FetchCollectionMethodParams
  ) => Promise<Array<ProductCollection | ProductCollectionEdge>>;
  productCollectionEntries: (
    collectionEntriesParams: FetchCollectionEntriesMethodParams
  ) => Promise<Array<Product | ProductEdge>>;
  contentCollectionEntries: (
    collectionEntriesParams: FetchCollectionEntriesMethodParams
  ) => Promise<Array<Content | ContentEdge>>;
  query: (queryParams: QueryParams) => Promise<JSON>;
  spaceProperties: () => Promise<SpaceProperties>;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  productSubscription: (
    observable: Observable<OperationResult, unknown>,
    nacelleEntryIds: string[]
  ) => () => void;
  productVariantSubscription: (
    observable: Observable<OperationResult, unknown>,
    nacelleEntryIds: string[]
  ) => () => void;
}

export interface OnDataErrorParams {
  method: string;
  params:
    | FetchMethodParams
    | FetchCollectionMethodParams
    | QueryParams
    | NavigationParams
    | null;
  error: Error | unknown;
}

export interface OnDataError {
  <T>(options: OnDataErrorParams): Promise<T> | T;
}

export interface AfterSubscription {
  method: string;
  callback: <T>(responseObj: T) => Promise<T> | T;
}

export function Storefront(params: StorefrontParams): StorefrontInstance {
  if (typeof params.token === 'undefined' || params.token.length === 0) {
    throw new Error('Nacelle space token is required.');
  }

  if (
    typeof params.storefrontEndpoint === 'undefined' ||
    params.storefrontEndpoint.length === 0
  ) {
    throw new Error('Nacelle endpoint is required');
  }

  const locale = params.locale || 'en-US';
  const debugMode =
    typeof params.debugMode !== 'undefined' ? params.debugMode : false;
  if (debugMode) {
    console.info(`ðŸ™Œ  Storefront Debug Mode Unlocked! ðŸ™Œ`);
  }

  const connector =
    params.connector ||
    new StorefrontConnector({
      token: params.token,
      endpoint: params.storefrontEndpoint,
      locale,
      debugMode,
    });

  let subscriptionConnector: SubscriptionConnector | undefined = undefined;
  if (params.subscriptionToken && params.subscriptionEndpoint) {
    subscriptionConnector = new SubscriptionConnector({
      token: params.subscriptionToken || '',
      endpoint: params.subscriptionEndpoint || '',
      debugMode,
    });
  }

  const currencyCode = params.currencyCode || 'USD';

  const onDataError: OnDataError | null = params.onDataError || null;

  const afterSubscriptions: AfterSubscription[] = [];

  async function applyAfter<T>(method: string, responseObj: T): Promise<T> {
    let response = responseObj;
    const subs = afterSubscriptions.filter((sub) => sub.method === method);

    for (const sub of subs) {
      response = await sub.callback<T>(response);
    }

    return response;
  }

  return {
    getConfig: (): StorefrontConfig => {
      return {
        token: params.token,
        storefrontEndpoint: params.storefrontEndpoint,
        locale,
        currencyCode,
        afterSubscriptions,
      };
    },

    products: async (
      productsParams?: FetchMethodParams
    ): Promise<Array<Product | ProductEdge>> => {
      try {
        const products = await connector.products(productsParams);
        return applyAfter<Array<Product | ProductEdge>>('products', products);
      } catch (error) {
        if (onDataError) {
          return onDataError<Array<Product | ProductEdge>>({
            method: 'products',
            params: productsParams || null,
            error,
          });
        }

        throw error;
      }
    },
    productCollections: async (
      productCollectionsParams?: FetchCollectionMethodParams
    ): Promise<Array<ProductCollection | ProductCollectionEdge>> => {
      console.info('storefront client, productCollections');
      try {
        const productCollections = await connector.productCollections(
          productCollectionsParams
        );
        return applyAfter<Array<ProductCollection | ProductCollectionEdge>>(
          'productCollections',
          productCollections
        );
      } catch (error) {
        if (onDataError) {
          return onDataError<Array<ProductCollection | ProductCollectionEdge>>({
            method: 'productCollections',
            params: productCollectionsParams || null,
            error,
          });
        }

        throw error;
      }
    },
    productCollectionEntries: async (
      collectionEntriesParams: FetchCollectionEntriesMethodParams
    ): Promise<Array<Product | ProductEdge>> => {
      console.info('storefront client, productCollectionEntries');
      try {
        const products = await connector.productCollectionEntries(
          collectionEntriesParams
        );
        return applyAfter<Array<Product | ProductEdge>>(
          'productCollectionEntries',
          products
        );
      } catch (error) {
        if (onDataError) {
          return onDataError<Array<Product | ProductEdge>>({
            method: 'productCollectionEntries',
            params: collectionEntriesParams || null,
            error,
          });
        }

        throw error;
      }
    },
    contentCollectionEntries: async (
      collectionEntriesParams: FetchCollectionEntriesMethodParams
    ): Promise<Array<Content | ContentEdge>> => {
      console.info('storefront client, contentCollectionEntries');
      try {
        const entries = await connector.contentCollectionEntries(
          collectionEntriesParams
        );
        return applyAfter<Array<Content | ContentEdge>>(
          'contentCollectionEntries',
          entries
        );
      } catch (error) {
        if (onDataError) {
          return onDataError<Array<Content | ContentEdge>>({
            method: 'contentCollectionEntries',
            params: collectionEntriesParams || null,
            error,
          });
        }

        throw error;
      }
    },
    content: async (
      contentParams?: FetchContentMethodParams
    ): Promise<Array<Content | ContentEdge>> => {
      try {
        const content = await connector.content(contentParams);
        return applyAfter<Array<Content | ContentEdge>>('content', content);
      } catch (error) {
        if (onDataError) {
          return onDataError<Array<Content | ContentEdge>>({
            method: 'content',
            params: contentParams || null,
            error,
          });
        }

        throw error;
      }
    },
    contentCollections: async (
      contentCollectionsParams?: FetchCollectionMethodParams
    ): Promise<Array<ContentCollection | ContentCollectionEdge>> => {
      try {
        const contentCollections = await connector.contentCollections(
          contentCollectionsParams
        );
        return applyAfter<Array<ContentCollection | ContentCollectionEdge>>(
          'contentCollections',
          contentCollections
        );
      } catch (error) {
        if (onDataError) {
          return onDataError<Array<ContentCollection | ContentCollectionEdge>>({
            method: 'contentCollections',
            params: contentCollectionsParams || null,
            error,
          });
        }

        throw error;
      }
    },
    productSubscription: (
      observable: Observable<OperationResult, unknown>,
      nacelleEntryIds: string[]
    ): (() => void) => {
      if (!subscriptionConnector) {
        const msg =
          'The params subscriptionToken && subscriptionEndpoint were not all provided';
        throw Error(msg);
      }
      return subscriptionConnector?.subscribeToProductUpdate(
        observable,
        nacelleEntryIds
      );
    },
    productVariantSubscription: (
      observable: Observable<OperationResult, unknown>,
      nacelleEntryIds: string[]
    ): (() => void) => {
      if (!subscriptionConnector) {
        const msg =
          'The params subscriptionToken && subscriptionEndpoint were not all provided';
        throw Error(msg);
      }
      return subscriptionConnector?.subscribeToProductVariantUpdate(
        observable,
        nacelleEntryIds
      );
    },
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    query: async (queryParams: QueryParams): Promise<JSON> => {
      try {
        const result = await connector.query(queryParams);
        return applyAfter<JSON>('query', result);
      } catch (error) {
        if (onDataError) {
          return onDataError<JSON>({
            method: 'query',
            params: queryParams,
            error,
          });
        }

        throw error;
      }
    },

    navigation: async (
      params?: NavigationParams
    ): Promise<NavigationGroup[]> => {
      try {
        const navigation = await connector.navigation(params);
        return applyAfter<NavigationGroup[]>('navigation', navigation);
      } catch (error) {
        if (onDataError) {
          return onDataError<NavigationGroup[]>({
            method: 'navigation',
            params: params || null,
            error,
          });
        }

        throw error;
      }
    },
    spaceProperties: async (): Promise<SpaceProperties> => {
      try {
        const spaceProperties = await connector.spaceProperties();
        return applyAfter<SpaceProperties>('spaceProperties', spaceProperties);
      } catch (error) {
        if (onDataError) {
          return onDataError<SpaceProperties>({
            method: 'spaceProperties',
            params: null,
            error,
          });
        }

        throw error;
      }
    },
    after(
      method: string,
      callback: <T>(responseObj: T) => Promise<T> | T
    ): void {
      afterSubscriptions.push({
        method,
        callback,
      });
    },
  };
}
