import {
  Content,
  ContentCollection,
  NavigationGroup,
  Product,
  ProductCollection,
  SpaceProperties,
  ProductCollectionEdge,
  ContentCollectionEdge,
  ProductEdge,
  ContentEdge,
} from '../types/graphql-generated';
import {
  FetchCollectionMethodParams,
  FetchContentMethodParams,
  FetchMethodParams,
  FetchCollectionEntriesMethodParams,
  GraphQLResponseRoot,
  HttpClient,
  NavigationParams,
  RequestParams,
  StorefrontConnectorParams,
  StorefrontRequestResponse,
  QueryParams,
  Connection,
  Edge,
} from '../types';

import {
  contentCollectionsQuery,
  contentQuery,
  navigation,
  productCollectionEntriesQuery,
  contentCollectionEntriesQuery,
  productCollectionsQuery,
  productsQuery,
  spaceProperties,
  allProductsQuery,
  allProductCollectionsQuery,
  allContentCollectionEntriesQuery,
  allContentCollectionsQuery,
  allContentQuery,
  allProductCollectionEntriesQuery,
} from '../graphql/queries';

import {
  HttpClientFetch,
  keepFetchingItems,
  DEFAULT_MAX_ENTRIES,
  DEFAULT_PAGE_FETCH_LIMIT,
  DEFAULT_MAX_ENTRIES_PER_COLLECTION,
  keepFetchingItemsUsingNextPage,
} from '../util';
import { handleGraphqlErrors, isGraphQLError } from './handle-errors';
import {
  lastEdgeCursor,
  mapCollectionConnectionToArray,
  nodesFromEdges,
} from '../util/edge-helpers';
import { checkDeprecatedQuery } from '../util/backwards-compatibility';

// TODO: move class methods into separate files for easier testing
export default class StorefrontConnector {
  token: string;
  endpoint: string;
  locale: string;
  httpClient: HttpClient;
  debugMode: boolean;

  constructor(params: StorefrontConnectorParams) {
    this.endpoint = params.endpoint;
    this.token = params.token;
    this.locale = params.locale;
    this.debugMode = params.debugMode || false;

    if (this.debugMode) {
      console.info('credentials:', {
        endpoint: this.endpoint,
        token: this.token,
      });
    }

    this.httpClient =
      params.httpClient ||
      new HttpClientFetch({
        headers: {
          'x-nacelle-space-token': this.token,
        },
      });
  }

  // TODO: clean up this method. too much branching logic
  async request<T>(
    params: RequestParams
  ): Promise<StorefrontRequestResponse<T>> {
    try {
      const { query, queryName, variables } = params;
      const data = {
        query,
        variables,
      };
      if (this.debugMode) {
        console.info('storefront request', {
          query: JSON.stringify(query),
          variables: JSON.stringify(variables),
        });
      }
      const response = await this.httpClient.post<GraphQLResponseRoot>(
        this.endpoint,
        data
      );

      if (response) {
        const graphqlResponse = response.data;

        if (isGraphQLError(graphqlResponse)) {
          handleGraphqlErrors(this, graphqlResponse.errors);
        }

        if (graphqlResponse.data) {
          if (queryName && graphqlResponse.data[queryName] !== 'undefined') {
            const queryResponseData: T = graphqlResponse.data[queryName] as T;
            return {
              success: true,
              data: queryResponseData,
            };
          }
          if (!queryName) {
            const queryResponseData: T = graphqlResponse.data as unknown as T;
            return {
              success: true,
              data: queryResponseData,
            };
          }
        }

        throw new Error(
          `Response did not include ${queryName}.
          ${JSON.stringify(graphqlResponse, null, 2)}`
        );
      }

      throw new Error(`No valid response from ${queryName}`);
    } catch (error) {
      return {
        success: false,
        error: (error as Error).message,
        data: null,
      };
    }
  }

  async requestCollectionEntries<T, C, Key extends keyof C>(options: {
    query: string;
    queryName: string;
    key: Key;
    params: FetchCollectionEntriesMethodParams;
  }): Promise<Array<T | Edge<T>>> {
    const { params, query, queryName, key } = options;
    const {
      cursor,
      collectionEntryId,
      handle,
      startAfterEntryId,
      maxReturnedEntries = DEFAULT_MAX_ENTRIES_PER_COLLECTION,
      locale,
      advancedOptions,
      edgesToNodes = true,
    } = params;

    if (collectionEntryId && handle) {
      console.warn(
        'You have supplied both a collectionEntryId and handle. This method will use collectionEntryId for querying.'
      );
    }

    if (!collectionEntryId && !handle) {
      throw new Error('You must provide either a collectionEntryId or handle.');
    }

    const isDeprecatedQuery = checkDeprecatedQuery(params);

    if (isDeprecatedQuery) {
      console.warn(
        `You are using the parameter, startAfterEntryId, for a deprecated 
Storefront API query, ${queryName}. This method and query will still return 
results, but you will have better improved results and pagination support 
using the parameter, cursor, instead.`
      );
    }

    const entriesFirst = Math.min(
      ...[
        advancedOptions?.entriesPerPage || DEFAULT_MAX_ENTRIES_PER_COLLECTION,
        maxReturnedEntries,
      ].filter((v) => v > 0)
    );
    let entriesAfter = isDeprecatedQuery ? startAfterEntryId : cursor;
    let allEntries: Array<T | Edge<T>> = [];
    let keepFetching = false;

    do {
      const response = await this.request<Connection<C>>({
        query,
        queryName,
        variables: {
          filter: {
            ...(collectionEntryId && { nacelleEntryIds: [collectionEntryId] }),
            ...(!collectionEntryId && handle ? { handles: [handle] } : {}),
            ...(locale ? { locale } : { locale: this.locale }),
          },
          entriesFirst,
          ...(entriesAfter && { entriesAfter }),
        },
      });

      if (response.success && response.data) {
        if (isDeprecatedQuery) {
          const collection = (response.data as unknown as C[])[0];
          const entries = collection[key] as unknown as T[];

          if (entries) {
            allEntries = allEntries.concat(entries);

            entriesAfter =
              entries.length > 0
                ? (entries[entries.length - 1] as unknown as Product | Content)
                    .nacelleEntryId
                : undefined;

            keepFetching = keepFetchingItems<T>(
              entries,
              allEntries as T[],
              maxReturnedEntries
            );
          }
        } else {
          const { edges } = response.data;

          if (edges.length === 0) {
            console.warn('No collections matching query');
          } else {
            const collection = nodesFromEdges(edges)[0];
            const entries = collection[key] as unknown as Connection<T>;

            if (entries) {
              const { pageInfo, edges: collectionEdges } = entries;
              const { hasNextPage } = pageInfo;
              const items = edgesToNodes
                ? nodesFromEdges(collectionEdges)
                : collectionEdges;
              allEntries = allEntries.concat(items);
              entriesAfter = lastEdgeCursor(collectionEdges);
              keepFetching = keepFetchingItemsUsingNextPage<T>(
                hasNextPage,
                allEntries,
                maxReturnedEntries
              );
            }
          }
        }
      } else {
        throw new Error(response.error);
      }
    } while (keepFetching);

    return allEntries;
  }

  /**
   * @description This is a helper method for fetching either pages of entries of
   * a given entry type or fetching entries by id or handles.
   * @param query The query to perform
   * @param queryName The query operation name
   * @param params method parameters that will be transformed into Storefront GraphQL
   * query variables.
   * @returns A promise for an array of type T
   */
  async requestEntries<T extends { nacelleEntryId: string }>(
    query: string,
    queryName: string,
    params?:
      | FetchMethodParams
      | FetchCollectionMethodParams
      | FetchContentMethodParams
  ): Promise<Array<T | Edge<T>>> {
    const {
      cursor,
      startAfterEntryId,
      nacelleEntryIds,
      handles,
      locale,
      maxReturnedEntries = DEFAULT_MAX_ENTRIES,
      advancedOptions,
      edgesToNodes = true,
      ...addlParams
    } = params || {};

    const {
      maxReturnedEntriesPerCollection = DEFAULT_MAX_ENTRIES_PER_COLLECTION,
    } = (params as FetchCollectionMethodParams) || {};

    const isCollectionQuery = [
      'productCollections',
      'contentCollections',
      'allProductCollections',
      'allContentCollections',
    ].includes(queryName);

    const isDeprecatedQuery = checkDeprecatedQuery(params);

    if (isDeprecatedQuery) {
      console.warn(
        `You are using the parameter, startAfterEntryId, for a deprecated 
Storefront API query, ${queryName}. This method and query will still return 
results, but you will have better improved results and pagination support 
using the parameter, cursor, instead.`
      );
    }

    if (
      (addlParams as Partial<FetchCollectionMethodParams>)
        .maxReturnedEntriesPerCollection
    ) {
      delete (addlParams as Partial<FetchCollectionMethodParams>)
        .maxReturnedEntriesPerCollection;
    }

    let nextAfter = isDeprecatedQuery ? startAfterEntryId : cursor;
    let keepFetching = true;
    let allEntries: Array<T | Edge<T>> = [];
    const filterArgs = {
      first: Math.min(
        ...[
          advancedOptions?.entriesPerPage || DEFAULT_PAGE_FETCH_LIMIT,
          maxReturnedEntries,
        ].filter((v) => v > 0)
      ),
      after: nextAfter,
      ...(locale ? { locale } : { locale: this.locale }),
      ...addlParams,
    };

    // TODO: refactor this entire method into smaller manageable methods.
    if (handles || nacelleEntryIds) {
      if (nacelleEntryIds && handles) {
        console.warn(
          'You have supplied both a nacelleEntryIds and handles. This method will use nacelleEntryIds for querying.'
        );
      }

      const chunk =
        advancedOptions?.entriesPerPage ||
        nacelleEntryIds?.length ||
        handles?.length ||
        DEFAULT_PAGE_FETCH_LIMIT;

      for (
        let i = 0, j = (nacelleEntryIds || handles || []).length;
        i < j &&
        (maxReturnedEntries > 0
          ? allEntries.length < maxReturnedEntries
          : true);
        i += chunk
      ) {
        const tempIds = (nacelleEntryIds || []).slice(i, i + chunk);
        const tempHandles =
          tempIds.length === 0 ? (handles || []).slice(i, i + chunk) : [];
        const response = await this.request<Connection<T>>({
          query,
          queryName,
          variables: {
            filter: {
              ...filterArgs,
              ...(tempIds.length > 0 ? { nacelleEntryIds: tempIds } : {}),
              ...(tempHandles.length > 0 ? { handles: tempHandles } : {}),
            },
            ...(isCollectionQuery && { maxReturnedEntriesPerCollection }),
          },
        });

        if (response.success && response.data) {
          if (isDeprecatedQuery) {
            const entries = response.data as unknown as T[];
            allEntries = allEntries.concat(entries);
          } else {
            const { edges } = response.data;
            const entries = edgesToNodes ? nodesFromEdges(edges) : edges;
            allEntries = allEntries.concat(entries);
          }
        } else {
          throw new Error(response.error);
        }
      }
    } else {
      do {
        const response = await this.request<Connection<T>>({
          query,
          queryName,
          variables: {
            filter: {
              ...filterArgs,
              after: nextAfter,
            },
            ...(isCollectionQuery && { maxReturnedEntriesPerCollection }),
          },
        });

        if (response.success && response.data) {
          if (isDeprecatedQuery) {
            const entries = response.data as unknown as T[];

            allEntries = allEntries.concat(entries);

            nextAfter =
              entries.length > 0
                ? entries[entries.length - 1].nacelleEntryId
                : undefined;

            keepFetching = keepFetchingItems<T>(
              entries,
              allEntries as T[],
              maxReturnedEntries
            );
          } else {
            const { pageInfo, edges } = response.data;
            const { hasNextPage } = pageInfo;
            const entries = edgesToNodes ? nodesFromEdges(edges) : edges;
            allEntries = allEntries.concat(entries);
            nextAfter = lastEdgeCursor<T>(edges);
            keepFetching = keepFetchingItemsUsingNextPage<T>(
              hasNextPage,
              allEntries,
              maxReturnedEntries
            );
          }
        } else {
          throw new Error(response.error);
        }
      } while (keepFetching);
    }

    return maxReturnedEntries > -1
      ? allEntries.slice(0, maxReturnedEntries)
      : allEntries;
  }

  async products(
    params?: FetchMethodParams
  ): Promise<Array<Product | ProductEdge>> {
    const isDeprecatedQuery = checkDeprecatedQuery(params);
    const query = isDeprecatedQuery ? productsQuery : allProductsQuery;
    const queryName = isDeprecatedQuery ? 'products' : 'allProducts';

    const products = await this.requestEntries<Product>(
      query,
      queryName,
      params
    );

    return products;
  }

  async productCollections(
    params?: FetchCollectionMethodParams
  ): Promise<Array<ProductCollection | ProductCollectionEdge>> {
    const { edgesToNodes = true } = params || {};
    const isDeprecatedQuery = checkDeprecatedQuery(params);
    const query = isDeprecatedQuery
      ? productCollectionsQuery
      : allProductCollectionsQuery;
    const queryName = isDeprecatedQuery
      ? 'productCollections'
      : 'allProductCollections';
    const collections = await this.requestEntries<ProductCollection>(
      query,
      queryName,
      params
    );

    if (isDeprecatedQuery) {
      return collections;
    }

    if (edgesToNodes) {
      return collections.map((collection) => {
        return mapCollectionConnectionToArray<
          Product,
          ProductCollection,
          'productConnection',
          'products'
        >(collection as ProductCollection, 'productConnection', 'products');
      });
    }
    return (collections as ProductCollectionEdge[]).map((edge) => {
      return {
        ...edge,
        node: mapCollectionConnectionToArray<
          Product,
          ProductCollection,
          'productConnection',
          'products'
        >(edge.node, 'productConnection', 'products'),
      };
    });
  }

  async content(
    params?: FetchContentMethodParams
  ): Promise<Array<Content | ContentEdge>> {
    const isDeprecatedQuery = checkDeprecatedQuery(params);
    const query = isDeprecatedQuery ? contentQuery : allContentQuery;
    const queryName = isDeprecatedQuery ? 'content' : 'allContent';
    const content = await this.requestEntries<Content>(
      query,
      queryName,
      params
    );

    return content;
  }

  async contentCollections(
    params?: FetchCollectionMethodParams
  ): Promise<Array<ContentCollection | ContentCollectionEdge>> {
    const { edgesToNodes = true } = params || {};
    const isDeprecatedQuery = checkDeprecatedQuery(params);
    const query = isDeprecatedQuery
      ? contentCollectionsQuery
      : allContentCollectionsQuery;
    const queryName = isDeprecatedQuery
      ? 'contentCollections'
      : 'allContentCollections';
    const collections = await this.requestEntries<ContentCollection>(
      query,
      queryName,
      params
    );

    if (isDeprecatedQuery) {
      return collections;
    }

    if (edgesToNodes) {
      return collections.map((collection) => {
        return mapCollectionConnectionToArray<
          Content,
          ContentCollection,
          'contentConnection',
          'entries'
        >(collection as ContentCollection, 'contentConnection', 'entries');
      });
    }

    return (collections as ContentCollectionEdge[]).map((edge) => {
      return {
        ...edge,
        node: mapCollectionConnectionToArray<
          Content,
          ContentCollection,
          'contentConnection',
          'entries'
        >(edge.node, 'contentConnection', 'entries'),
      };
    });
  }

  async navigation(params?: NavigationParams): Promise<NavigationGroup[]> {
    const requestParams: RequestParams = {
      query: navigation,
      queryName: 'navigation',
    };

    if (params) {
      requestParams.variables = { filter: params };
    }

    const response = await this.request<NavigationGroup[]>(requestParams);

    if (response.success && response.data) {
      return response.data;
    }

    throw new Error(response.error);
  }

  async query(params: QueryParams): Promise<JSON> {
    const { query, variables } = params;

    const response = await this.request<JSON>({
      query,
      variables,
    });

    if (response.success && response.data) {
      return response.data;
    }

    throw new Error(response.error);
  }

  async spaceProperties(): Promise<SpaceProperties> {
    const response = await this.request<SpaceProperties>({
      query: spaceProperties,
      queryName: 'spaceProperties',
    });

    if (response.success && response.data) {
      return response.data;
    }

    throw new Error(response.error);
  }

  async productCollectionEntries(
    params: FetchCollectionEntriesMethodParams
  ): Promise<Array<Product | ProductEdge>> {
    const isDeprecatedQuery = checkDeprecatedQuery(params);
    const query = isDeprecatedQuery
      ? productCollectionEntriesQuery
      : allProductCollectionEntriesQuery;
    const queryName = isDeprecatedQuery
      ? 'productCollections'
      : 'allProductCollections';
    const key = isDeprecatedQuery ? 'products' : 'productConnection';

    return this.requestCollectionEntries<
      Product,
      ProductCollection,
      'products' | 'productConnection'
    >({
      query,
      queryName,
      key,
      params,
    });
  }

  async contentCollectionEntries(
    params: FetchCollectionEntriesMethodParams
  ): Promise<Array<Content | ContentEdge>> {
    const isDeprecatedQuery = checkDeprecatedQuery(params);
    const query = isDeprecatedQuery
      ? contentCollectionEntriesQuery
      : allContentCollectionEntriesQuery;
    const queryName = isDeprecatedQuery
      ? 'contentCollections'
      : 'allContentCollections';
    const key = isDeprecatedQuery ? 'entries' : 'contentConnection';

    return this.requestCollectionEntries<
      Content,
      ContentCollection,
      'entries' | 'contentConnection'
    >({
      query,
      queryName,
      key,
      params,
    });
  }
}
