import {
  createClient,
  defaultExchanges,
  subscriptionExchange,
  OperationResult,
  Client,
} from '@urql/core';
import { createClient as createWSClient } from 'graphql-ws';
import { pipe, subscribe } from 'wonka';

import { SubscriptionConnectorParams } from '../types';

import {
  productSubscription,
  productVariantSubscription,
} from '../graphql/queries';

export interface productData {
  nacelleEntryId: string;
  entryType: string;
  availableForSale: boolean;
}

export interface variantResult {
  variantInventoryUpdatedFilter: {
    nacelleEntryIds: string[];
  };
}

export interface Observable<D, E> {
  onNext: (data: D) => void;
  onError: (error: E) => void;
}

export default class SubscriptionConnector {
  token: string;
  endpoint: string;
  wsClient: Client;
  debugMode?: boolean;

  constructor(params: SubscriptionConnectorParams) {
    this.endpoint = params.endpoint;
    this.token = params.token;
    this.debugMode = params.debugMode || false;

    if (this.debugMode) {
      console.info('credentials:', {
        endpoint: this.endpoint,
        token: this.token,
      });
    }

    const headers = {
      'x-nacelle-tether-access-token': this.token,
    };

    const subscriptionClient = createWSClient({
      url: this.endpoint,
      connectionParams: headers,
      isFatalConnectionProblem: (errOrCloseEvent: unknown) => {
        const typeObj: Record<string, unknown> = errOrCloseEvent as Record<
          string,
          unknown
        >;
        if (typeObj.code === 4403) {
          console.error(
            'Websocket server rejecting auth, check headers for correct x-nacelle-space-id and x-nacelle-tether-access-token'
          );
          return true;
        }
        return false;
      },
    });

    this.wsClient =
      params.wsClient ||
      createClient({
        url: this.endpoint,
        exchanges: [
          ...defaultExchanges,
          subscriptionExchange({
            forwardSubscription(operation) {
              return {
                subscribe: (sink) => {
                  const dispose = subscriptionClient.subscribe(operation, sink);
                  return {
                    unsubscribe: dispose,
                  };
                },
              };
            },
          }),
        ],
      });
  }

  subscribeToProductUpdate = (
    observable: Observable<OperationResult, unknown>,
    nacelleEntryIds: string[]
  ): (() => void) => {
    if (!this.wsClient) {
      throw new Error('No wsClient');
    }
    try {
      const { unsubscribe } = pipe(
        this.wsClient.subscription(productSubscription, {
          productInventoryUpdatedFilter: { nacelleEntryIds },
        }),
        subscribe((result) => {
          if (result.error) {
            observable.onError(result);
          } else {
            observable.onNext(result as OperationResult);
          }
        })
      );
      return unsubscribe;
    } catch (err) {
      observable.onError(err);
      // eslint-disable-next-line @typescript-eslint/no-empty-function
      return () => {};
    }
  };

  subscribeToProductVariantUpdate = (
    observable: Observable<OperationResult, unknown>,
    nacelleEntryIds: string[]
  ): (() => void) => {
    if (!this.wsClient) {
      throw new Error('No wsClient');
    }
    try {
      const { unsubscribe } = pipe(
        this.wsClient.subscription(productVariantSubscription, {
          variantInventoryUpdatedFilter: { nacelleEntryIds },
        }),
        subscribe((result) => {
          if (result.error) {
            observable.onError(result);
          } else {
            observable.onNext(result as OperationResult);
          }
        })
      );
      return unsubscribe;
    } catch (err) {
      observable.onError(err);
      // eslint-disable-next-line @typescript-eslint/no-empty-function
      return () => {};
    }
  };
}
