{"version":3,"file":"storefront-sdk.cjs.production.min.js","sources":["../node_modules/regenerator-runtime/runtime.js","../src/util/keep-fetching-items.ts","../src/util/http-client-fetch.ts","../src/StorefrontConnector/handle-errors.ts","../src/util/edge-helpers.ts","../src/util/backwards-compatibility.ts","../src/types/entry-model.ts","../src/types/locales.ts","../src/StorefrontConnector/index.ts","../src/util/constants.ts","../src/SubscriptionConnector/index.ts","../src/StorefrontClient/index.ts"],"sourcesContent":["/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  define(Gp, \"constructor\", GeneratorFunctionPrototype);\n  define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction);\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  });\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  define(Gp, iteratorSymbol, function() {\n    return this;\n  });\n\n  define(Gp, \"toString\", function() {\n    return \"[object Generator]\";\n  });\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, in modern engines\n  // we can explicitly access globalThis. In older engines we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}\n","import { Edge } from '../types';\n\nexport function keepFetchingItems<T>(\n  fetchedItems: T[],\n  totalItems: T[],\n  maxReturnedEntries: number | undefined\n): boolean {\n  const lessItemsThanRequested = maxReturnedEntries\n    ? maxReturnedEntries === -1 || totalItems.length < maxReturnedEntries\n    : true;\n  return fetchedItems.length > 0 && lessItemsThanRequested;\n}\n\nexport function keepFetchingItemsUsingNextPage<T>(\n  hasNextPage: boolean | null | undefined,\n  totalItems: Array<T | Edge<T>>,\n  maxReturnedEntries: number | undefined\n): boolean {\n  const lessItemsThanRequested =\n    typeof maxReturnedEntries === 'undefined' || maxReturnedEntries === -1\n      ? true\n      : maxReturnedEntries !== 0 && totalItems.length < maxReturnedEntries;\n  return Boolean(hasNextPage) && lessItemsThanRequested;\n}\n","import fetch from 'cross-fetch';\nimport { HttpClient, HttpClientResponse } from '../types/http';\n\nexport interface FetchResponse {\n  headers: Headers;\n  ok: boolean;\n  redirected: boolean;\n  status: number;\n  statusText: string;\n  type: ResponseType;\n  url: string;\n}\n\nexport class HttpClientFetch implements HttpClient {\n  options: RequestInit;\n\n  constructor(options?: RequestInit) {\n    const defaultOptions = {\n      timeout: 240000,\n    };\n    const defaultHeaders = {\n      'Content-Type': 'application/json',\n      'x-nacelle-sdk-version': '__sdkVersion__',\n    };\n    const { headers, ...otherOptions } = options || {};\n\n    this.options = {\n      headers: {\n        ...defaultHeaders,\n        ...headers,\n      },\n      ...defaultOptions,\n      ...otherOptions,\n    };\n  }\n\n  async get<T>(url: string): Promise<HttpClientResponse<T>> {\n    const response: Response = await fetch(url, {\n      ...this.options,\n      method: 'GET',\n    });\n    const data: T = await response.json();\n\n    return {\n      headers: response.headers,\n      status: response.status,\n      statusText: response.statusText,\n      data,\n    };\n  }\n\n  async post<T>(url: string, data: unknown): Promise<HttpClientResponse<T>> {\n    const response: Response = await fetch(url, {\n      ...this.options,\n      method: 'POST',\n      body: JSON.stringify(data),\n    });\n    const responseData: T = await response.json();\n\n    return {\n      headers: response.headers,\n      status: response.status,\n      statusText: response.statusText,\n      data: responseData,\n    };\n  }\n}\n","import { GraphQLResponseRoot, GraphQLResponseError } from '../types/graphql';\nimport { StorefrontConnectorParams } from '../types/storefront-connector';\n\nexport const isGraphQLError = (data: GraphQLResponseRoot): boolean => {\n  return Boolean(data.errors && data.errors.length > 0);\n};\n\nexport const handleGraphqlErrors = (\n  connectorParams: StorefrontConnectorParams,\n  errors?: GraphQLResponseError[]\n): void => {\n  let errorMessage = 'Storefront GraphQL Error:';\n\n  if (errors && errors.length > 0) {\n    const { unauthenticated, otherErrors } = errors.reduce(\n      (categories, error) => {\n        if (error.extensions?.code === 'UNAUTHENTICATED') {\n          categories.unauthenticated.push(error);\n        } else {\n          categories.otherErrors.push(error);\n        }\n\n        return categories;\n      },\n      { unauthenticated: [], otherErrors: [] } as {\n        unauthenticated: GraphQLResponseError[];\n        otherErrors: GraphQLResponseError[];\n      }\n    );\n\n    unauthenticated.forEach((error) => {\n      if (\n        error.message.indexOf('x-nacelle-space-token') > -1 ||\n        error.message.indexOf('Token is invalid') > -1\n      ) {\n        errorMessage += ` The Storefront SDK client is trying to use an invalid Storefront API token, ${connectorParams.token}, for ${connectorParams.endpoint}.\nPlease verify that the client is initialized with the correct token parameter.'`;\n      }\n    });\n\n    otherErrors.forEach((error, index, arr) => {\n      const { nacelleErrorId } = error.extensions || {};\n      const displayIndex =\n        arr.length > 1 ? ` (${index + 1} of ${arr.length}) ` : '';\n      const displayErrorId = nacelleErrorId\n        ? ` (Error Ref Id: ${nacelleErrorId})`\n        : '';\n\n      errorMessage += `${displayIndex}${error.message}${displayErrorId}`;\n    });\n\n    if (connectorParams.debugMode) {\n      console.info(\n        'Storefront SDK Debug: GraphQL Error Details',\n        JSON.stringify(errors)\n      );\n    }\n\n    throw new Error(errorMessage);\n  }\n};\n","import { Edge, Connection } from '../types';\n\nexport function nodesFromEdges<T>(edges: Edge<T>[] | undefined): T[] {\n  return edges ? edges.map(({ node }) => node) : [];\n}\n\nexport function lastEdgeCursor<T>(\n  edges: Edge<T>[] | undefined\n): string | undefined {\n  return edges && edges.length > 0 ? edges[edges.length - 1].cursor : undefined;\n}\n\nexport function mapCollectionConnectionToArray<\n  T,\n  C,\n  ConnectionKey extends keyof C,\n  PlacementKey extends keyof C\n>(collection: C, connectionKey: ConnectionKey, placementKey: PlacementKey): C {\n  const connection = collection[connectionKey] as unknown as Connection<T>;\n  return {\n    ...collection,\n    [placementKey]: nodesFromEdges(connection.edges),\n  };\n}\n","import { FetchMethodParams } from '../types';\n\nexport function checkDeprecatedQuery(\n  params: FetchMethodParams | undefined\n): boolean {\n  return Boolean(\n    params &&\n      typeof params.startAfterEntryId !== 'undefined' &&\n      params.startAfterEntryId.length > 0\n  );\n}\n","import {\n  Content,\n  Product,\n  ProductContent,\n  Variant,\n  VariantContent,\n  CollectionContent,\n  ContentCollection,\n  ProductCollection,\n} from './graphql-generated';\n\nexport enum EntryType {\n  PRODUCT = 'product',\n  PRODUCT_CONTENT = 'product-content',\n  VARIANT = 'variant',\n  VARIANT_CONTENT = 'variant-content',\n  CONTENT = 'content',\n  CONTENT_COLLECTION = 'content-collection',\n  PRODUCT_COLLECTION = 'product-collection',\n  COLLECTION_CONTENT = 'collection-content',\n}\n\nexport type Entry =\n  | Content\n  | Product\n  | ProductContent\n  | Variant\n  | VariantContent\n  | ContentCollection\n  | ProductCollection\n  | CollectionContent;\n\nexport enum DataSourceName {\n  SHOPIFY = 'shopify',\n  CONTENTFUL = 'contentful',\n  SANITY = 'sanity',\n}\n","/**\n * An enum with the common IETF language tags. We can\n * use a library for this in the future since there\n * are a lot and we don't want to manage this ourselves.\n * A quick search had a library, but it did not have types.\n * This list can be found here: https://gist.github.com/traysr/2001377\n */\nexport enum Locales {\n  en = 'en',\n  en_US = 'en-US',\n  en_GB = 'en-GB',\n  fr = 'fr',\n  de = 'de',\n  pl = 'pl',\n  nl = 'nl',\n  fi = 'fi',\n  sv = 'sv',\n  it = 'it',\n  es = 'es',\n  pt = 'pt',\n  ru = 'ru',\n  pt_BR = 'pt-BR',\n  es_MX = 'es-MX',\n  zh_CN = 'zh-CN',\n  zh_TW = 'zh-TW',\n  jp = 'ja',\n  ko = 'ko',\n}\n","import {\n  Content,\n  ContentCollection,\n  NavigationGroup,\n  Product,\n  ProductCollection,\n  SpaceProperties,\n  ProductCollectionEdge,\n  ContentCollectionEdge,\n  ProductEdge,\n  ContentEdge,\n} from '../types/graphql-generated';\nimport {\n  FetchCollectionMethodParams,\n  FetchContentMethodParams,\n  FetchMethodParams,\n  FetchCollectionEntriesMethodParams,\n  GraphQLResponseRoot,\n  HttpClient,\n  NavigationParams,\n  RequestParams,\n  StorefrontConnectorParams,\n  StorefrontRequestResponse,\n  QueryParams,\n  Connection,\n  Edge,\n} from '../types';\n\nimport {\n  contentCollectionsQuery,\n  contentQuery,\n  navigation,\n  productCollectionEntriesQuery,\n  contentCollectionEntriesQuery,\n  productCollectionsQuery,\n  productsQuery,\n  spaceProperties,\n  allProductsQuery,\n  allProductCollectionsQuery,\n  allContentCollectionEntriesQuery,\n  allContentCollectionsQuery,\n  allContentQuery,\n  allProductCollectionEntriesQuery,\n} from '../graphql/queries';\n\nimport {\n  HttpClientFetch,\n  keepFetchingItems,\n  DEFAULT_MAX_ENTRIES,\n  DEFAULT_PAGE_FETCH_LIMIT,\n  DEFAULT_MAX_ENTRIES_PER_COLLECTION,\n  keepFetchingItemsUsingNextPage,\n} from '../util';\nimport { handleGraphqlErrors, isGraphQLError } from './handle-errors';\nimport {\n  lastEdgeCursor,\n  mapCollectionConnectionToArray,\n  nodesFromEdges,\n} from '../util/edge-helpers';\nimport { checkDeprecatedQuery } from '../util/backwards-compatibility';\n\n// TODO: move class methods into separate files for easier testing\nexport default class StorefrontConnector {\n  token: string;\n  endpoint: string;\n  locale: string;\n  httpClient: HttpClient;\n  debugMode: boolean;\n\n  constructor(params: StorefrontConnectorParams) {\n    this.endpoint = params.endpoint;\n    this.token = params.token;\n    this.locale = params.locale;\n    this.debugMode = params.debugMode || false;\n\n    if (this.debugMode) {\n      console.info('credentials:', {\n        endpoint: this.endpoint,\n        token: this.token,\n      });\n    }\n\n    this.httpClient =\n      params.httpClient ||\n      new HttpClientFetch({\n        headers: {\n          'x-nacelle-space-token': this.token,\n        },\n      });\n  }\n\n  // TODO: clean up this method. too much branching logic\n  async request<T>(\n    params: RequestParams\n  ): Promise<StorefrontRequestResponse<T>> {\n    try {\n      const { query, queryName, variables } = params;\n      const data = {\n        query,\n        variables,\n      };\n      if (this.debugMode) {\n        console.info('storefront request', {\n          query: JSON.stringify(query),\n          variables: JSON.stringify(variables),\n        });\n      }\n      const response = await this.httpClient.post<GraphQLResponseRoot>(\n        this.endpoint,\n        data\n      );\n\n      if (response) {\n        const graphqlResponse = response.data;\n\n        if (isGraphQLError(graphqlResponse)) {\n          handleGraphqlErrors(this, graphqlResponse.errors);\n        }\n\n        if (graphqlResponse.data) {\n          if (queryName && graphqlResponse.data[queryName] !== 'undefined') {\n            const queryResponseData: T = graphqlResponse.data[queryName] as T;\n            return {\n              success: true,\n              data: queryResponseData,\n            };\n          }\n          if (!queryName) {\n            const queryResponseData: T = graphqlResponse.data as unknown as T;\n            return {\n              success: true,\n              data: queryResponseData,\n            };\n          }\n        }\n\n        throw new Error(\n          `Response did not include ${queryName}.\n          ${JSON.stringify(graphqlResponse, null, 2)}`\n        );\n      }\n\n      throw new Error(`No valid response from ${queryName}`);\n    } catch (error) {\n      return {\n        success: false,\n        error: (error as Error).message,\n        data: null,\n      };\n    }\n  }\n\n  async requestCollectionEntries<T, C, Key extends keyof C>(options: {\n    query: string;\n    queryName: string;\n    key: Key;\n    params: FetchCollectionEntriesMethodParams;\n  }): Promise<Array<T | Edge<T>>> {\n    const { params, query, queryName, key } = options;\n    const {\n      cursor,\n      collectionEntryId,\n      handle,\n      startAfterEntryId,\n      maxReturnedEntries = DEFAULT_MAX_ENTRIES_PER_COLLECTION,\n      locale,\n      advancedOptions,\n      edgesToNodes = true,\n    } = params;\n\n    if (collectionEntryId && handle) {\n      console.warn(\n        'You have supplied both a collectionEntryId and handle. This method will use collectionEntryId for querying.'\n      );\n    }\n\n    if (!collectionEntryId && !handle) {\n      throw new Error('You must provide either a collectionEntryId or handle.');\n    }\n\n    const isDeprecatedQuery = checkDeprecatedQuery(params);\n\n    if (isDeprecatedQuery) {\n      console.warn(\n        `You are using the parameter, startAfterEntryId, for a deprecated \nStorefront API query, ${queryName}. This method and query will still return \nresults, but you will have better improved results and pagination support \nusing the parameter, cursor, instead.`\n      );\n    }\n\n    const entriesFirst = Math.min(\n      ...[\n        advancedOptions?.entriesPerPage || DEFAULT_MAX_ENTRIES_PER_COLLECTION,\n        maxReturnedEntries,\n      ].filter((v) => v > 0)\n    );\n    let entriesAfter = isDeprecatedQuery ? startAfterEntryId : cursor;\n    let allEntries: Array<T | Edge<T>> = [];\n    let keepFetching = false;\n\n    do {\n      const response = await this.request<Connection<C>>({\n        query,\n        queryName,\n        variables: {\n          filter: {\n            ...(collectionEntryId && { nacelleEntryIds: [collectionEntryId] }),\n            ...(!collectionEntryId && handle ? { handles: [handle] } : {}),\n            ...(locale ? { locale } : { locale: this.locale }),\n          },\n          entriesFirst,\n          ...(entriesAfter && { entriesAfter }),\n        },\n      });\n\n      if (response.success && response.data) {\n        if (isDeprecatedQuery) {\n          const collection = (response.data as unknown as C[])[0];\n          const entries = collection[key] as unknown as T[];\n\n          if (entries) {\n            allEntries = allEntries.concat(entries);\n\n            entriesAfter =\n              entries.length > 0\n                ? (entries[entries.length - 1] as unknown as Product | Content)\n                    .nacelleEntryId\n                : undefined;\n\n            keepFetching = keepFetchingItems<T>(\n              entries,\n              allEntries as T[],\n              maxReturnedEntries\n            );\n          }\n        } else {\n          const { edges } = response.data;\n\n          if (edges.length === 0) {\n            console.warn('No collections matching query');\n          } else {\n            const collection = nodesFromEdges(edges)[0];\n            const entries = collection[key] as unknown as Connection<T>;\n\n            if (entries) {\n              const { pageInfo, edges: collectionEdges } = entries;\n              const { hasNextPage } = pageInfo;\n              const items = edgesToNodes\n                ? nodesFromEdges(collectionEdges)\n                : collectionEdges;\n              allEntries = allEntries.concat(items);\n              entriesAfter = lastEdgeCursor(collectionEdges);\n              keepFetching = keepFetchingItemsUsingNextPage<T>(\n                hasNextPage,\n                allEntries,\n                maxReturnedEntries\n              );\n            }\n          }\n        }\n      } else {\n        throw new Error(response.error);\n      }\n    } while (keepFetching);\n\n    return allEntries;\n  }\n\n  /**\n   * @description This is a helper method for fetching either pages of entries of\n   * a given entry type or fetching entries by id or handles.\n   * @param query The query to perform\n   * @param queryName The query operation name\n   * @param params method parameters that will be transformed into Storefront GraphQL\n   * query variables.\n   * @returns A promise for an array of type T\n   */\n  async requestEntries<T extends { nacelleEntryId: string }>(\n    query: string,\n    queryName: string,\n    params?:\n      | FetchMethodParams\n      | FetchCollectionMethodParams\n      | FetchContentMethodParams\n  ): Promise<Array<T | Edge<T>>> {\n    const {\n      cursor,\n      startAfterEntryId,\n      nacelleEntryIds,\n      handles,\n      locale,\n      maxReturnedEntries = DEFAULT_MAX_ENTRIES,\n      advancedOptions,\n      edgesToNodes = true,\n      ...addlParams\n    } = params || {};\n\n    const {\n      maxReturnedEntriesPerCollection = DEFAULT_MAX_ENTRIES_PER_COLLECTION,\n    } = (params as FetchCollectionMethodParams) || {};\n\n    const isCollectionQuery = [\n      'productCollections',\n      'contentCollections',\n      'allProductCollections',\n      'allContentCollections',\n    ].includes(queryName);\n\n    const isDeprecatedQuery = checkDeprecatedQuery(params);\n\n    if (isDeprecatedQuery) {\n      console.warn(\n        `You are using the parameter, startAfterEntryId, for a deprecated \nStorefront API query, ${queryName}. This method and query will still return \nresults, but you will have better improved results and pagination support \nusing the parameter, cursor, instead.`\n      );\n    }\n\n    if (\n      (addlParams as Partial<FetchCollectionMethodParams>)\n        .maxReturnedEntriesPerCollection\n    ) {\n      delete (addlParams as Partial<FetchCollectionMethodParams>)\n        .maxReturnedEntriesPerCollection;\n    }\n\n    let nextAfter = isDeprecatedQuery ? startAfterEntryId : cursor;\n    let keepFetching = true;\n    let allEntries: Array<T | Edge<T>> = [];\n    const filterArgs = {\n      first: Math.min(\n        ...[\n          advancedOptions?.entriesPerPage || DEFAULT_PAGE_FETCH_LIMIT,\n          maxReturnedEntries,\n        ].filter((v) => v > 0)\n      ),\n      after: nextAfter,\n      ...(locale ? { locale } : { locale: this.locale }),\n      ...addlParams,\n    };\n\n    // TODO: refactor this entire method into smaller manageable methods.\n    if (handles || nacelleEntryIds) {\n      if (nacelleEntryIds && handles) {\n        console.warn(\n          'You have supplied both a nacelleEntryIds and handles. This method will use nacelleEntryIds for querying.'\n        );\n      }\n\n      const chunk =\n        advancedOptions?.entriesPerPage ||\n        nacelleEntryIds?.length ||\n        handles?.length ||\n        DEFAULT_PAGE_FETCH_LIMIT;\n\n      for (\n        let i = 0, j = (nacelleEntryIds || handles || []).length;\n        i < j &&\n        (maxReturnedEntries > 0\n          ? allEntries.length < maxReturnedEntries\n          : true);\n        i += chunk\n      ) {\n        const tempIds = (nacelleEntryIds || []).slice(i, i + chunk);\n        const tempHandles =\n          tempIds.length === 0 ? (handles || []).slice(i, i + chunk) : [];\n        const response = await this.request<Connection<T>>({\n          query,\n          queryName,\n          variables: {\n            filter: {\n              ...filterArgs,\n              ...(tempIds.length > 0 ? { nacelleEntryIds: tempIds } : {}),\n              ...(tempHandles.length > 0 ? { handles: tempHandles } : {}),\n            },\n            ...(isCollectionQuery && { maxReturnedEntriesPerCollection }),\n          },\n        });\n\n        if (response.success && response.data) {\n          if (isDeprecatedQuery) {\n            const entries = response.data as unknown as T[];\n            allEntries = allEntries.concat(entries);\n          } else {\n            const { edges } = response.data;\n            const entries = edgesToNodes ? nodesFromEdges(edges) : edges;\n            allEntries = allEntries.concat(entries);\n          }\n        } else {\n          throw new Error(response.error);\n        }\n      }\n    } else {\n      do {\n        const response = await this.request<Connection<T>>({\n          query,\n          queryName,\n          variables: {\n            filter: {\n              ...filterArgs,\n              after: nextAfter,\n            },\n            ...(isCollectionQuery && { maxReturnedEntriesPerCollection }),\n          },\n        });\n\n        if (response.success && response.data) {\n          if (isDeprecatedQuery) {\n            const entries = response.data as unknown as T[];\n\n            allEntries = allEntries.concat(entries);\n\n            nextAfter =\n              entries.length > 0\n                ? entries[entries.length - 1].nacelleEntryId\n                : undefined;\n\n            keepFetching = keepFetchingItems<T>(\n              entries,\n              allEntries as T[],\n              maxReturnedEntries\n            );\n          } else {\n            const { pageInfo, edges } = response.data;\n            const { hasNextPage } = pageInfo;\n            const entries = edgesToNodes ? nodesFromEdges(edges) : edges;\n            allEntries = allEntries.concat(entries);\n            nextAfter = lastEdgeCursor<T>(edges);\n            keepFetching = keepFetchingItemsUsingNextPage<T>(\n              hasNextPage,\n              allEntries,\n              maxReturnedEntries\n            );\n          }\n        } else {\n          throw new Error(response.error);\n        }\n      } while (keepFetching);\n    }\n\n    return maxReturnedEntries > -1\n      ? allEntries.slice(0, maxReturnedEntries)\n      : allEntries;\n  }\n\n  async products(\n    params?: FetchMethodParams\n  ): Promise<Array<Product | ProductEdge>> {\n    const isDeprecatedQuery = checkDeprecatedQuery(params);\n    const query = isDeprecatedQuery ? productsQuery : allProductsQuery;\n    const queryName = isDeprecatedQuery ? 'products' : 'allProducts';\n\n    const products = await this.requestEntries<Product>(\n      query,\n      queryName,\n      params\n    );\n\n    return products;\n  }\n\n  async productCollections(\n    params?: FetchCollectionMethodParams\n  ): Promise<Array<ProductCollection | ProductCollectionEdge>> {\n    const { edgesToNodes = true } = params || {};\n    const isDeprecatedQuery = checkDeprecatedQuery(params);\n    const query = isDeprecatedQuery\n      ? productCollectionsQuery\n      : allProductCollectionsQuery;\n    const queryName = isDeprecatedQuery\n      ? 'productCollections'\n      : 'allProductCollections';\n    const collections = await this.requestEntries<ProductCollection>(\n      query,\n      queryName,\n      params\n    );\n\n    if (isDeprecatedQuery) {\n      return collections;\n    }\n\n    if (edgesToNodes) {\n      return collections.map((collection) => {\n        return mapCollectionConnectionToArray<\n          Product,\n          ProductCollection,\n          'productConnection',\n          'products'\n        >(collection as ProductCollection, 'productConnection', 'products');\n      });\n    }\n    return (collections as ProductCollectionEdge[]).map((edge) => {\n      return {\n        ...edge,\n        node: mapCollectionConnectionToArray<\n          Product,\n          ProductCollection,\n          'productConnection',\n          'products'\n        >(edge.node, 'productConnection', 'products'),\n      };\n    });\n  }\n\n  async content(\n    params?: FetchContentMethodParams\n  ): Promise<Array<Content | ContentEdge>> {\n    const isDeprecatedQuery = checkDeprecatedQuery(params);\n    const query = isDeprecatedQuery ? contentQuery : allContentQuery;\n    const queryName = isDeprecatedQuery ? 'content' : 'allContent';\n    const content = await this.requestEntries<Content>(\n      query,\n      queryName,\n      params\n    );\n\n    return content;\n  }\n\n  async contentCollections(\n    params?: FetchCollectionMethodParams\n  ): Promise<Array<ContentCollection | ContentCollectionEdge>> {\n    const { edgesToNodes = true } = params || {};\n    const isDeprecatedQuery = checkDeprecatedQuery(params);\n    const query = isDeprecatedQuery\n      ? contentCollectionsQuery\n      : allContentCollectionsQuery;\n    const queryName = isDeprecatedQuery\n      ? 'contentCollections'\n      : 'allContentCollections';\n    const collections = await this.requestEntries<ContentCollection>(\n      query,\n      queryName,\n      params\n    );\n\n    if (isDeprecatedQuery) {\n      return collections;\n    }\n\n    if (edgesToNodes) {\n      return collections.map((collection) => {\n        return mapCollectionConnectionToArray<\n          Content,\n          ContentCollection,\n          'contentConnection',\n          'entries'\n        >(collection as ContentCollection, 'contentConnection', 'entries');\n      });\n    }\n\n    return (collections as ContentCollectionEdge[]).map((edge) => {\n      return {\n        ...edge,\n        node: mapCollectionConnectionToArray<\n          Content,\n          ContentCollection,\n          'contentConnection',\n          'entries'\n        >(edge.node, 'contentConnection', 'entries'),\n      };\n    });\n  }\n\n  async navigation(params?: NavigationParams): Promise<NavigationGroup[]> {\n    const requestParams: RequestParams = {\n      query: navigation,\n      queryName: 'navigation',\n    };\n\n    if (params) {\n      requestParams.variables = { filter: params };\n    }\n\n    const response = await this.request<NavigationGroup[]>(requestParams);\n\n    if (response.success && response.data) {\n      return response.data;\n    }\n\n    throw new Error(response.error);\n  }\n\n  async query(params: QueryParams): Promise<JSON> {\n    const { query, variables } = params;\n\n    const response = await this.request<JSON>({\n      query,\n      variables,\n    });\n\n    if (response.success && response.data) {\n      return response.data;\n    }\n\n    throw new Error(response.error);\n  }\n\n  async spaceProperties(): Promise<SpaceProperties> {\n    const response = await this.request<SpaceProperties>({\n      query: spaceProperties,\n      queryName: 'spaceProperties',\n    });\n\n    if (response.success && response.data) {\n      return response.data;\n    }\n\n    throw new Error(response.error);\n  }\n\n  async productCollectionEntries(\n    params: FetchCollectionEntriesMethodParams\n  ): Promise<Array<Product | ProductEdge>> {\n    const isDeprecatedQuery = checkDeprecatedQuery(params);\n    const query = isDeprecatedQuery\n      ? productCollectionEntriesQuery\n      : allProductCollectionEntriesQuery;\n    const queryName = isDeprecatedQuery\n      ? 'productCollections'\n      : 'allProductCollections';\n    const key = isDeprecatedQuery ? 'products' : 'productConnection';\n\n    return this.requestCollectionEntries<\n      Product,\n      ProductCollection,\n      'products' | 'productConnection'\n    >({\n      query,\n      queryName,\n      key,\n      params,\n    });\n  }\n\n  async contentCollectionEntries(\n    params: FetchCollectionEntriesMethodParams\n  ): Promise<Array<Content | ContentEdge>> {\n    const isDeprecatedQuery = checkDeprecatedQuery(params);\n    const query = isDeprecatedQuery\n      ? contentCollectionEntriesQuery\n      : allContentCollectionEntriesQuery;\n    const queryName = isDeprecatedQuery\n      ? 'contentCollections'\n      : 'allContentCollections';\n    const key = isDeprecatedQuery ? 'entries' : 'contentConnection';\n\n    return this.requestCollectionEntries<\n      Content,\n      ContentCollection,\n      'entries' | 'contentConnection'\n    >({\n      query,\n      queryName,\n      key,\n      params,\n    });\n  }\n}\n","export const DEFAULT_PAGE_FETCH_LIMIT = 250;\nexport const DEFAULT_MAX_ENTRIES = -1; // Always fetch complete index by default\nexport const DEFAULT_MAX_ENTRIES_PER_COLLECTION = 25;\n","import {\n  createClient,\n  defaultExchanges,\n  subscriptionExchange,\n  OperationResult,\n  Client,\n} from '@urql/core';\nimport { createClient as createWSClient } from 'graphql-ws';\nimport { pipe, subscribe } from 'wonka';\n\nimport { SubscriptionConnectorParams } from '../types';\n\nimport {\n  productSubscription,\n  productVariantSubscription,\n} from '../graphql/queries';\n\nexport interface productData {\n  nacelleEntryId: string;\n  entryType: string;\n  availableForSale: boolean;\n}\n\nexport interface variantResult {\n  variantInventoryUpdatedFilter: {\n    nacelleEntryIds: string[];\n  };\n}\n\nexport interface Observable<D, E> {\n  onNext: (data: D) => void;\n  onError: (error: E) => void;\n}\n\nexport default class SubscriptionConnector {\n  token: string;\n  endpoint: string;\n  wsClient: Client;\n  debugMode?: boolean;\n\n  constructor(params: SubscriptionConnectorParams) {\n    this.endpoint = params.endpoint;\n    this.token = params.token;\n    this.debugMode = params.debugMode || false;\n\n    if (this.debugMode) {\n      console.info('credentials:', {\n        endpoint: this.endpoint,\n        token: this.token,\n      });\n    }\n\n    const headers = {\n      'x-nacelle-tether-access-token': this.token,\n    };\n\n    const subscriptionClient = createWSClient({\n      url: this.endpoint,\n      connectionParams: headers,\n      isFatalConnectionProblem: (errOrCloseEvent: unknown) => {\n        const typeObj: Record<string, unknown> = errOrCloseEvent as Record<\n          string,\n          unknown\n        >;\n        if (typeObj.code === 4403) {\n          console.error(\n            'Websocket server rejecting auth, check headers for correct x-nacelle-space-id and x-nacelle-tether-access-token'\n          );\n          return true;\n        }\n        return false;\n      },\n    });\n\n    this.wsClient =\n      params.wsClient ||\n      createClient({\n        url: this.endpoint,\n        exchanges: [\n          ...defaultExchanges,\n          subscriptionExchange({\n            forwardSubscription(operation) {\n              return {\n                subscribe: (sink) => {\n                  const dispose = subscriptionClient.subscribe(operation, sink);\n                  return {\n                    unsubscribe: dispose,\n                  };\n                },\n              };\n            },\n          }),\n        ],\n      });\n  }\n\n  subscribeToProductUpdate = (\n    observable: Observable<OperationResult, unknown>,\n    nacelleEntryIds: string[]\n  ): (() => void) => {\n    if (!this.wsClient) {\n      throw new Error('No wsClient');\n    }\n    try {\n      const { unsubscribe } = pipe(\n        this.wsClient.subscription(productSubscription, {\n          productInventoryUpdatedFilter: { nacelleEntryIds },\n        }),\n        subscribe((result) => {\n          if (result.error) {\n            observable.onError(result);\n          } else {\n            observable.onNext(result as OperationResult);\n          }\n        })\n      );\n      return unsubscribe;\n    } catch (err) {\n      observable.onError(err);\n      // eslint-disable-next-line @typescript-eslint/no-empty-function\n      return () => {};\n    }\n  };\n\n  subscribeToProductVariantUpdate = (\n    observable: Observable<OperationResult, unknown>,\n    nacelleEntryIds: string[]\n  ): (() => void) => {\n    if (!this.wsClient) {\n      throw new Error('No wsClient');\n    }\n    try {\n      const { unsubscribe } = pipe(\n        this.wsClient.subscription(productVariantSubscription, {\n          variantInventoryUpdatedFilter: { nacelleEntryIds },\n        }),\n        subscribe((result) => {\n          if (result.error) {\n            observable.onError(result);\n          } else {\n            observable.onNext(result as OperationResult);\n          }\n        })\n      );\n      return unsubscribe;\n    } catch (err) {\n      observable.onError(err);\n      // eslint-disable-next-line @typescript-eslint/no-empty-function\n      return () => {};\n    }\n  };\n}\n","import { OperationResult } from '@urql/core';\n\nimport {\n  ContentCollection,\n  Content,\n  NavigationGroup,\n  ProductCollection,\n  Product,\n  SpaceProperties,\n  ContentEdge,\n  ProductEdge,\n  ProductCollectionEdge,\n  ContentCollectionEdge,\n} from '../types/graphql-generated';\n\nimport {\n  FetchMethodParams,\n  FetchCollectionMethodParams,\n  FetchContentMethodParams,\n  FetchCollectionEntriesMethodParams,\n  NavigationParams,\n  QueryParams,\n} from '../types/parameters';\n\nimport StorefrontConnector from '../StorefrontConnector';\nimport SubscriptionConnector, { Observable } from '../SubscriptionConnector';\n\nexport interface StorefrontParams {\n  token: string;\n  storefrontEndpoint: string;\n  currencyCode?: string;\n  locale?: string;\n  connector?: StorefrontConnector;\n  onDataError?: OnDataError;\n  debugMode?: boolean;\n  subscriptionEndpoint?: string;\n  subscriptionToken?: string;\n  subscriptionSpaceId?: string;\n}\n\nexport interface StorefrontConfig extends StorefrontParams {\n  afterSubscriptions: AfterSubscription[];\n}\n\nexport interface StorefrontInstance {\n  after: (\n    method: string,\n    callback: <T>(responseObj: T) => Promise<T> | T\n  ) => void;\n  content: (\n    contentParams?: FetchContentMethodParams\n  ) => Promise<Array<Content | ContentEdge>>;\n  contentCollections: (\n    contentCollectionsParams?: FetchCollectionMethodParams\n  ) => Promise<Array<ContentCollection | ContentCollectionEdge>>;\n  getConfig: () => StorefrontConfig;\n  navigation: (params?: NavigationParams) => Promise<NavigationGroup[]>;\n  products: (\n    productsParams?: FetchMethodParams\n  ) => Promise<Array<Product | ProductEdge>>;\n  productCollections: (\n    productCollectionsParams?: FetchCollectionMethodParams\n  ) => Promise<Array<ProductCollection | ProductCollectionEdge>>;\n  productCollectionEntries: (\n    collectionEntriesParams: FetchCollectionEntriesMethodParams\n  ) => Promise<Array<Product | ProductEdge>>;\n  contentCollectionEntries: (\n    collectionEntriesParams: FetchCollectionEntriesMethodParams\n  ) => Promise<Array<Content | ContentEdge>>;\n  query: (queryParams: QueryParams) => Promise<JSON>;\n  spaceProperties: () => Promise<SpaceProperties>;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  productSubscription: (\n    observable: Observable<OperationResult, unknown>,\n    nacelleEntryIds: string[]\n  ) => () => void;\n  productVariantSubscription: (\n    observable: Observable<OperationResult, unknown>,\n    nacelleEntryIds: string[]\n  ) => () => void;\n}\n\nexport interface OnDataErrorParams {\n  method: string;\n  params:\n    | FetchMethodParams\n    | FetchCollectionMethodParams\n    | QueryParams\n    | NavigationParams\n    | null;\n  error: Error | unknown;\n}\n\nexport interface OnDataError {\n  <T>(options: OnDataErrorParams): Promise<T> | T;\n}\n\nexport interface AfterSubscription {\n  method: string;\n  callback: <T>(responseObj: T) => Promise<T> | T;\n}\n\nexport function Storefront(params: StorefrontParams): StorefrontInstance {\n  if (typeof params.token === 'undefined' || params.token.length === 0) {\n    throw new Error('Nacelle space token is required.');\n  }\n\n  if (\n    typeof params.storefrontEndpoint === 'undefined' ||\n    params.storefrontEndpoint.length === 0\n  ) {\n    throw new Error('Nacelle endpoint is required');\n  }\n\n  const locale = params.locale || 'en-US';\n  const debugMode =\n    typeof params.debugMode !== 'undefined' ? params.debugMode : false;\n  if (debugMode) {\n    console.info(`🙌  Storefront Debug Mode Unlocked! 🙌`);\n  }\n\n  const connector =\n    params.connector ||\n    new StorefrontConnector({\n      token: params.token,\n      endpoint: params.storefrontEndpoint,\n      locale,\n      debugMode,\n    });\n\n  let subscriptionConnector: SubscriptionConnector | undefined = undefined;\n  if (params.subscriptionToken && params.subscriptionEndpoint) {\n    subscriptionConnector = new SubscriptionConnector({\n      token: params.subscriptionToken || '',\n      endpoint: params.subscriptionEndpoint || '',\n      debugMode,\n    });\n  }\n\n  const currencyCode = params.currencyCode || 'USD';\n\n  const onDataError: OnDataError | null = params.onDataError || null;\n\n  const afterSubscriptions: AfterSubscription[] = [];\n\n  async function applyAfter<T>(method: string, responseObj: T): Promise<T> {\n    let response = responseObj;\n    const subs = afterSubscriptions.filter((sub) => sub.method === method);\n\n    for (const sub of subs) {\n      response = await sub.callback<T>(response);\n    }\n\n    return response;\n  }\n\n  return {\n    getConfig: (): StorefrontConfig => {\n      return {\n        token: params.token,\n        storefrontEndpoint: params.storefrontEndpoint,\n        locale,\n        currencyCode,\n        afterSubscriptions,\n      };\n    },\n\n    products: async (\n      productsParams?: FetchMethodParams\n    ): Promise<Array<Product | ProductEdge>> => {\n      try {\n        const products = await connector.products(productsParams);\n        return applyAfter<Array<Product | ProductEdge>>('products', products);\n      } catch (error) {\n        if (onDataError) {\n          return onDataError<Array<Product | ProductEdge>>({\n            method: 'products',\n            params: productsParams || null,\n            error,\n          });\n        }\n\n        throw error;\n      }\n    },\n    productCollections: async (\n      productCollectionsParams?: FetchCollectionMethodParams\n    ): Promise<Array<ProductCollection | ProductCollectionEdge>> => {\n      console.info('storefront client, productCollections');\n      try {\n        const productCollections = await connector.productCollections(\n          productCollectionsParams\n        );\n        return applyAfter<Array<ProductCollection | ProductCollectionEdge>>(\n          'productCollections',\n          productCollections\n        );\n      } catch (error) {\n        if (onDataError) {\n          return onDataError<Array<ProductCollection | ProductCollectionEdge>>({\n            method: 'productCollections',\n            params: productCollectionsParams || null,\n            error,\n          });\n        }\n\n        throw error;\n      }\n    },\n    productCollectionEntries: async (\n      collectionEntriesParams: FetchCollectionEntriesMethodParams\n    ): Promise<Array<Product | ProductEdge>> => {\n      console.info('storefront client, productCollectionEntries');\n      try {\n        const products = await connector.productCollectionEntries(\n          collectionEntriesParams\n        );\n        return applyAfter<Array<Product | ProductEdge>>(\n          'productCollectionEntries',\n          products\n        );\n      } catch (error) {\n        if (onDataError) {\n          return onDataError<Array<Product | ProductEdge>>({\n            method: 'productCollectionEntries',\n            params: collectionEntriesParams || null,\n            error,\n          });\n        }\n\n        throw error;\n      }\n    },\n    contentCollectionEntries: async (\n      collectionEntriesParams: FetchCollectionEntriesMethodParams\n    ): Promise<Array<Content | ContentEdge>> => {\n      console.info('storefront client, contentCollectionEntries');\n      try {\n        const entries = await connector.contentCollectionEntries(\n          collectionEntriesParams\n        );\n        return applyAfter<Array<Content | ContentEdge>>(\n          'contentCollectionEntries',\n          entries\n        );\n      } catch (error) {\n        if (onDataError) {\n          return onDataError<Array<Content | ContentEdge>>({\n            method: 'contentCollectionEntries',\n            params: collectionEntriesParams || null,\n            error,\n          });\n        }\n\n        throw error;\n      }\n    },\n    content: async (\n      contentParams?: FetchContentMethodParams\n    ): Promise<Array<Content | ContentEdge>> => {\n      try {\n        const content = await connector.content(contentParams);\n        return applyAfter<Array<Content | ContentEdge>>('content', content);\n      } catch (error) {\n        if (onDataError) {\n          return onDataError<Array<Content | ContentEdge>>({\n            method: 'content',\n            params: contentParams || null,\n            error,\n          });\n        }\n\n        throw error;\n      }\n    },\n    contentCollections: async (\n      contentCollectionsParams?: FetchCollectionMethodParams\n    ): Promise<Array<ContentCollection | ContentCollectionEdge>> => {\n      try {\n        const contentCollections = await connector.contentCollections(\n          contentCollectionsParams\n        );\n        return applyAfter<Array<ContentCollection | ContentCollectionEdge>>(\n          'contentCollections',\n          contentCollections\n        );\n      } catch (error) {\n        if (onDataError) {\n          return onDataError<Array<ContentCollection | ContentCollectionEdge>>({\n            method: 'contentCollections',\n            params: contentCollectionsParams || null,\n            error,\n          });\n        }\n\n        throw error;\n      }\n    },\n    productSubscription: (\n      observable: Observable<OperationResult, unknown>,\n      nacelleEntryIds: string[]\n    ): (() => void) => {\n      if (!subscriptionConnector) {\n        const msg =\n          'The params subscriptionToken && subscriptionEndpoint were not all provided';\n        throw Error(msg);\n      }\n      return subscriptionConnector?.subscribeToProductUpdate(\n        observable,\n        nacelleEntryIds\n      );\n    },\n    productVariantSubscription: (\n      observable: Observable<OperationResult, unknown>,\n      nacelleEntryIds: string[]\n    ): (() => void) => {\n      if (!subscriptionConnector) {\n        const msg =\n          'The params subscriptionToken && subscriptionEndpoint were not all provided';\n        throw Error(msg);\n      }\n      return subscriptionConnector?.subscribeToProductVariantUpdate(\n        observable,\n        nacelleEntryIds\n      );\n    },\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    query: async (queryParams: QueryParams): Promise<JSON> => {\n      try {\n        const result = await connector.query(queryParams);\n        return applyAfter<JSON>('query', result);\n      } catch (error) {\n        if (onDataError) {\n          return onDataError<JSON>({\n            method: 'query',\n            params: queryParams,\n            error,\n          });\n        }\n\n        throw error;\n      }\n    },\n\n    navigation: async (\n      params?: NavigationParams\n    ): Promise<NavigationGroup[]> => {\n      try {\n        const navigation = await connector.navigation(params);\n        return applyAfter<NavigationGroup[]>('navigation', navigation);\n      } catch (error) {\n        if (onDataError) {\n          return onDataError<NavigationGroup[]>({\n            method: 'navigation',\n            params: params || null,\n            error,\n          });\n        }\n\n        throw error;\n      }\n    },\n    spaceProperties: async (): Promise<SpaceProperties> => {\n      try {\n        const spaceProperties = await connector.spaceProperties();\n        return applyAfter<SpaceProperties>('spaceProperties', spaceProperties);\n      } catch (error) {\n        if (onDataError) {\n          return onDataError<SpaceProperties>({\n            method: 'spaceProperties',\n            params: null,\n            error,\n          });\n        }\n\n        throw error;\n      }\n    },\n    after(\n      method: string,\n      callback: <T>(responseObj: T) => Promise<T> | T\n    ): void {\n      afterSubscriptions.push({\n        method,\n        callback,\n      });\n    },\n  };\n}\n"],"names":["runtime","exports","undefined","Op","Object","prototype","hasOwn","hasOwnProperty","$Symbol","Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","obj","key","value","defineProperty","enumerable","configurable","writable","err","wrap","innerFn","outerFn","self","tryLocsList","generator","create","Generator","context","Context","_invoke","state","GenStateSuspendedStart","method","arg","GenStateExecuting","Error","GenStateCompleted","doneResult","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","type","done","GenStateSuspendedYield","makeInvokeMethod","fn","call","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","this","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","AsyncIterator","PromiseImpl","invoke","resolve","reject","result","__await","then","unwrapped","error","previousPromise","callInvokeWithMethodAndArg","TypeError","info","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","length","i","displayName","isGeneratorFunction","genFun","ctor","constructor","name","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","keys","object","reverse","pop","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","catch","thrown","delegateYield","module","regeneratorRuntime","accidentalStrictMode","globalThis","Function","keepFetchingItems","fetchedItems","totalItems","maxReturnedEntries","keepFetchingItemsUsingNextPage","hasNextPage","lessItemsThanRequested","Boolean","HttpClientFetch","options","headers","otherOptions","timeout","get","url","fetch","response","json","status","statusText","data","post","body","JSON","stringify","isGraphQLError","errors","handleGraphqlErrors","connectorParams","errorMessage","reduce","categories","extensions","code","unauthenticated","otherErrors","message","indexOf","token","endpoint","index","arr","nacelleErrorId","debugMode","console","nodesFromEdges","edges","map","node","lastEdgeCursor","cursor","mapCollectionConnectionToArray","collection","connectionKey","placementKey","checkDeprecatedQuery","params","startAfterEntryId","EntryType","DataSourceName","Locales","StorefrontConnector","locale","httpClient","request","queryName","query","variables","graphqlResponse","success","_context","requestCollectionEntries","advancedOptions","edgesToNodes","collectionEntryId","warn","isDeprecatedQuery","entriesFirst","Math","min","entriesPerPage","filter","v","entriesAfter","allEntries","keepFetching","nacelleEntryIds","handles","entries","concat","nacelleEntryId","collectionEdges","pageInfo","items","requestEntries","addlParams","maxReturnedEntriesPerCollection","isCollectionQuery","includes","nextAfter","filterArgs","first","after","chunk","j","tempIds","tempHandles","products","productCollections","collections","edge","content","contentCollections","navigation","requestParams","spaceProperties","productCollectionEntries","contentCollectionEntries","SubscriptionConnector","wsClient","subscribeToProductUpdate","observable","_this","pipe","subscription","productInventoryUpdatedFilter","subscribe","onError","onNext","unsubscribe","subscribeToProductVariantUpdate","variantInventoryUpdatedFilter","subscriptionClient","createWSClient","connectionParams","isFatalConnectionProblem","errOrCloseEvent","createClient","exchanges","defaultExchanges","subscriptionExchange","forwardSubscription","operation","sink","Storefront","storefrontEndpoint","connector","subscriptionConnector","subscriptionToken","subscriptionEndpoint","currencyCode","onDataError","afterSubscriptions","applyAfter","responseObj","subs","sub","callback","getConfig","productsParams","productCollectionsParams","collectionEntriesParams","contentParams","contentCollectionsParams","productSubscription","_subscriptionConnecto","productVariantSubscription","_subscriptionConnecto2","queryParams"],"mappings":"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"}