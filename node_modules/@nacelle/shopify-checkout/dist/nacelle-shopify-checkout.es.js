var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function buildCheckout({
  id,
  webUrl
}) {
  return {
    id,
    url: webUrl,
    completed: false
  };
}
function cartItemsToCheckoutItems({
  cartItems
}) {
  const lineItems = cartItems.map((cartItem) => {
    const {
      quantity,
      variantId: providedVariantId
    } = cartItem;
    const variantId = transformVariantIdToGid(providedVariantId);
    const customAttributes = metafieldsToCustomAttributes({
      metafields: cartItem.metafields
    });
    return {
      customAttributes,
      quantity,
      variantId
    };
  });
  return lineItems;
}
function sanitizeShopifyDomain(domain) {
  var _a, _b;
  const sanitizedDomain = (_b = (_a = domain == null ? void 0 : domain.split(".myshopify").shift()) == null ? void 0 : _a.split("//").pop()) == null ? void 0 : _b.split(".").pop();
  return sanitizedDomain || domain;
}
const fetchClientError = "[@nacelle/shopify-checkout] in order to create a checkout server-side, you must provide a fetch API-compatible `fetchClient` capable of running on both the client & server. Examples include `isomorphic-unfetch` and `cross-fetch`.";
const missingParametersErrorMessage = "[@nacelle/shopify-checkout]: missing required parameters. Either use both `myshopifyDomain` and `storefrontApiVersion`, or provide a `customEndpoint`.";
function createGqlClient({
  customEndpoint,
  fetchClient,
  myshopifyDomain,
  storefrontApiVersion,
  storefrontCheckoutToken
}) {
  const gqlClient = ({
    query,
    variables
  }) => {
    let endpoint = customEndpoint;
    if (!endpoint) {
      if (!myshopifyDomain || !storefrontApiVersion) {
        throw new Error(missingParametersErrorMessage);
      }
      const domain = sanitizeShopifyDomain(myshopifyDomain || "");
      endpoint = `https://${domain}.myshopify.com/api/${storefrontApiVersion}/graphql`;
    }
    let fetcher = fetchClient;
    if (!fetcher) {
      if (typeof window !== "undefined") {
        fetcher = window.fetch;
      } else {
        throw new Error(fetchClientError);
      }
    }
    return fetcher(endpoint, {
      method: "POST",
      headers: {
        Accept: "application/json",
        "Content-Type": "application/json",
        "X-Shopify-Storefront-Access-Token": storefrontCheckoutToken
      },
      body: JSON.stringify({
        query,
        variables
      })
    }).then((res) => res.json());
  };
  return gqlClient;
}
function gql(str, ...values) {
  return str.reduce((acc, s, i) => `${acc}${s}${values[i] || ""}`, "");
}
function handleShopifyError(errors, {
  caller,
  message
} = {}) {
  let errorMessage = "";
  if (caller) {
    errorMessage = `[${caller}] `;
  }
  errorMessage = errorMessage + (message || "Shopify Storefront API Errors:") + (errors ? "\n" + JSON.stringify(errors, null, 2) : "");
  throw new Error(errorMessage);
}
function isVerifiedCheckoutId(id) {
  if (!(id == null ? void 0 : id.length)) {
    return false;
  }
  return id.includes("Z2lkOi8vc2hvcGlmeS9DaGVja291dC8") && id !== "";
}
function metafieldsToCustomAttributes({
  metafields
}) {
  if (!Array.isArray(metafields) || !(metafields == null ? void 0 : metafields.length)) {
    return [];
  }
  const customAttributes = metafields == null ? void 0 : metafields.reduce((fields, m) => {
    if (typeof m.value === "string") {
      fields.push({
        key: m.key,
        value: m.value
      });
    } else {
      console.warn(`Omitting custom attribute "${m.key}" because it has a non-string value.`);
    }
    return fields;
  }, []);
  return customAttributes;
}
function transformVariantIdToGid(variantId) {
  if (isPlainTextGlobalId(variantId)) {
    return variantId;
  }
  if (isNumeric(variantId)) {
    return idToVariantGid(variantId);
  }
  const decodedVariantId = decodeBase64Id(variantId);
  if (isPlainTextGlobalId(decodedVariantId)) {
    return decodedVariantId;
  }
  throw Error(`${variantId} is an invalid shopify variant id`);
}
function isPlainTextGlobalId(variantId) {
  return variantId.startsWith("gid://shopify/");
}
function isNumeric(variantId) {
  return !Number.isNaN(Number(variantId));
}
function decodeBase64Id(variantId) {
  try {
    if (typeof window === "undefined") {
      if (Buffer.from(variantId, "base64").toString("base64") === variantId) {
        return Buffer.from(variantId, "base64").toString();
      } else {
        return variantId;
      }
    } else {
      return window.atob(variantId);
    }
  } catch (err) {
    return variantId;
  }
}
function idToVariantGid(variantId) {
  return `gid://shopify/ProductVariant/${variantId}`;
}
const checkoutCreate = gql`mutation checkoutCreate($input: CheckoutCreateInput!) { checkoutCreate(input: $input) { checkout { id webUrl } checkoutUserErrors { code field message } } }`;
const checkoutLineItemsReplace$1 = gql`mutation checkoutLineItemsReplace( $lineItems: [CheckoutLineItemInput!]! $checkoutId: ID! ) { checkoutLineItemsReplace(lineItems: $lineItems, checkoutId: $checkoutId) { checkout { id webUrl } userErrors { code field message } } }`;
const checkoutAttributesUpdate$1 = gql`mutation checkoutAttributesUpdate( $checkoutId: ID! $input: CheckoutAttributesUpdateV2Input! ) { checkoutAttributesUpdateV2(checkoutId: $checkoutId, input: $input) { checkout { id webUrl } checkoutUserErrors { code field message } } }`;
function checkoutAttributesUpdate(_0) {
  return __async(this, arguments, function* ({
    gqlClient,
    id,
    customAttributes,
    note
  }) {
    const query = checkoutAttributesUpdate$1;
    const variables = {
      checkoutId: id,
      input: {
        customAttributes,
        note
      }
    };
    const {
      data,
      errors
    } = yield gqlClient({
      query,
      variables
    }).catch((err) => {
      throw new Error(err);
    });
    const errs = errors || (data == null ? void 0 : data.checkoutAttributesUpdateV2.checkoutUserErrors);
    if (errs == null ? void 0 : errs.length) {
      handleShopifyError(errs, {
        caller: "checkoutAttributesUpdate"
      });
    }
    if (data == null ? void 0 : data.checkoutAttributesUpdateV2.checkout) {
      return buildCheckout(data.checkoutAttributesUpdateV2.checkout);
    }
  });
}
function createCheckout(_0) {
  return __async(this, arguments, function* ({
    gqlClient,
    lineItems,
    customAttributes,
    note,
    queueToken
  }) {
    const query = checkoutCreate;
    const variables = {
      input: {
        customAttributes,
        lineItems,
        note
      },
      queueToken
    };
    try {
      const {
        data,
        errors
      } = yield gqlClient({
        query,
        variables
      }).catch((err) => {
        throw new Error(err);
      });
      const errs = errors || (data == null ? void 0 : data.checkoutCreate.checkoutUserErrors);
      if (errs == null ? void 0 : errs.length) {
        handleShopifyError(errors, {
          caller: "checkoutCreate"
        });
      }
      if (data == null ? void 0 : data.checkoutCreate.checkout) {
        return buildCheckout(data.checkoutCreate.checkout);
      }
    } catch (err) {
      throw new Error(String(err));
    }
  });
}
function checkoutLineItemsReplace(_0) {
  return __async(this, arguments, function* ({
    gqlClient,
    lineItems,
    id
  }) {
    const query = checkoutLineItemsReplace$1;
    const variables = {
      checkoutId: id,
      lineItems
    };
    const {
      data,
      errors
    } = yield gqlClient({
      query,
      variables
    }).catch((err) => {
      throw new Error(err);
    });
    const errs = errors || (data == null ? void 0 : data.checkoutLineItemsReplace.userErrors);
    if (errs == null ? void 0 : errs.length) {
      handleShopifyError(errs, {
        caller: "checkoutLineItemsReplace"
      });
    }
    if (data == null ? void 0 : data.checkoutLineItemsReplace.checkout) {
      return buildCheckout(data.checkoutLineItemsReplace.checkout);
    }
  });
}
const getCheckout = gql`query getCheckout($id: ID!) { node(id: $id) { ... on Checkout { id webUrl completedAt } } }`;
function findCheckout(_0) {
  return __async(this, arguments, function* ({
    gqlClient,
    id
  }) {
    const query = getCheckout;
    const variables = {
      id
    };
    const {
      data,
      errors
    } = yield gqlClient({
      query,
      variables
    }).catch((err) => {
      throw new Error(err);
    });
    if (errors) {
      handleShopifyError(errors, {
        caller: "findCheckout"
      });
    }
    if (!(data == null ? void 0 : data.node)) {
      handleShopifyError(void 0, {
        caller: "findCheckout",
        message: "Checkout response has no data"
      });
    } else {
      const {
        id: id2,
        webUrl,
        completedAt
      } = data.node;
      return {
        completed: Boolean(completedAt),
        id: id2 || "",
        url: webUrl || ""
      };
    }
  });
}
function putCheckout(_0) {
  return __async(this, arguments, function* ({
    gqlClient,
    id,
    lineItems,
    customAttributes,
    note,
    queueToken
  }) {
    let checkout = void 0;
    const shouldUpdateLineItems = lineItems == null ? void 0 : lineItems.length;
    const shouldUpdateAttributes = (customAttributes == null ? void 0 : customAttributes.length) || note;
    try {
      if (id) {
        if (!isVerifiedCheckoutId(id)) {
          throw new Error(`Invalid checkout ID. Expected a Base64-encoded Shopify Global ID. Received: ${id}`);
        }
        const checkoutUpdatePromises = [];
        if (shouldUpdateLineItems) {
          checkoutUpdatePromises.push(checkoutLineItemsReplace({
            gqlClient,
            id,
            lineItems
          }));
        }
        if (shouldUpdateAttributes) {
          checkoutUpdatePromises.push(checkoutAttributesUpdate({
            gqlClient,
            id,
            customAttributes,
            note
          }));
        }
        yield Promise.allSettled(checkoutUpdatePromises).then((settledPromises) => settledPromises.forEach((p) => {
          if (p.status === "fulfilled" && p.value) {
            checkout = __spreadValues(__spreadValues({}, checkout || {}), p.value);
          } else if (p.status === "rejected") {
            throw new Error(p.reason);
          }
        }));
      }
      if (typeof checkout === "undefined" && typeof lineItems !== "undefined") {
        checkout = yield createCheckout({
          gqlClient,
          customAttributes,
          note,
          lineItems,
          queueToken
        });
      }
      return checkout;
    } catch (err) {
      throw new Error(String(err));
    }
  });
}
function createShopifyCheckoutClient({
  storefrontCheckoutToken,
  myshopifyDomain,
  storefrontApiVersion,
  customEndpoint,
  fetchClient
}) {
  const gqlClient = createGqlClient({
    customEndpoint,
    fetchClient,
    myshopifyDomain,
    storefrontApiVersion,
    storefrontCheckoutToken
  });
  function getCheckout2(_0) {
    return __async(this, arguments, function* ({
      id
    }) {
      return yield findCheckout({
        gqlClient,
        id
      });
    });
  }
  function processCheckout(_0) {
    return __async(this, arguments, function* ({
      cartItems,
      id,
      metafields,
      note,
      queueToken
    }) {
      const lineItems = (cartItems == null ? void 0 : cartItems.length) ? cartItemsToCheckoutItems({
        cartItems
      }) : void 0;
      const customAttributes = (metafields == null ? void 0 : metafields.length) ? metafieldsToCustomAttributes({
        metafields
      }) : void 0;
      return yield putCheckout({
        gqlClient,
        lineItems,
        id,
        customAttributes,
        note,
        queueToken
      });
    });
  }
  return {
    get: getCheckout2,
    process: processCheckout
  };
}
export { createShopifyCheckoutClient as default };
//# sourceMappingURL=nacelle-shopify-checkout.es.js.map
