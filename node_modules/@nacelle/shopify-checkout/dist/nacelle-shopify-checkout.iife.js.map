{"version":3,"file":"nacelle-shopify-checkout.iife.js","sources":["../src/utils/buildCheckout.ts","../src/utils/cartItemsToCheckoutItems.ts","../src/utils/createGqlClient.ts","../src/utils/gql.ts","../src/utils/handleShopifyError.ts","../src/utils/isVerifiedCheckoutId.ts","../src/utils/metafieldsToCustomAttributes.ts","../src/utils/transformVariantIdToGid.ts","../src/graphql/mutations/index.ts","../src/client/actions/checkoutAttributesUpdate.ts","../src/client/actions/checkoutCreate.ts","../src/client/actions/checkoutLineItemsReplace.ts","../src/graphql/queries/index.ts","../src/client/actions/findCheckout.ts","../src/client/actions/putCheckout.ts","../src/client/index.ts"],"sourcesContent":["import { BuildCheckoutParams, ShopifyCheckout } from '../checkout-client.types';\n\nexport default function buildCheckout({\n  id,\n  webUrl\n}: BuildCheckoutParams): ShopifyCheckout {\n  return {\n    id,\n    url: webUrl,\n    completed: false\n  };\n}\n","import { CartItem, CheckoutItem } from '../checkout-client.types';\nimport {\n  metafieldsToCustomAttributes,\n  transformVariantIdToGid\n} from '../utils';\n\nexport interface CartItemsToCheckoutItemsParams {\n  cartItems: CartItem[];\n}\n\nexport default function cartItemsToCheckoutItems({\n  cartItems\n}: CartItemsToCheckoutItemsParams): CheckoutItem[] {\n  const lineItems: CheckoutItem[] = cartItems.map((cartItem) => {\n    const { quantity, variantId: providedVariantId } = cartItem;\n    const variantId = transformVariantIdToGid(providedVariantId);\n    const customAttributes = metafieldsToCustomAttributes({\n      metafields: cartItem.metafields\n    });\n\n    return { customAttributes, quantity, variantId };\n  });\n\n  return lineItems;\n}\n","import { GqlClient } from '../checkout-client.types';\nimport { CreateClientParams } from '../client';\n\n/**\n * Sanitize `(brand).myshopify.com` domains.\n */\nfunction sanitizeShopifyDomain(domain: string): string {\n  const sanitizedDomain = domain\n    ?.split('.myshopify')\n    .shift()\n    ?.split('//')\n    .pop()\n    ?.split('.')\n    .pop();\n\n  return sanitizedDomain || domain;\n}\n\nexport const fetchClientError =\n  '[@nacelle/shopify-checkout] in order to create a checkout server-side, ' +\n  'you must provide a fetch API-compatible `fetchClient` capable of running ' +\n  'on both the client & server. Examples include `isomorphic-unfetch` and `cross-fetch`.';\n\ntype CreateGqlClientParams = Pick<\n  CreateClientParams,\n  | 'customEndpoint'\n  | 'fetchClient'\n  | 'myshopifyDomain'\n  | 'storefrontApiVersion'\n  | 'storefrontCheckoutToken'\n>;\n\nexport const missingParametersErrorMessage =\n  '[@nacelle/shopify-checkout]: missing required parameters. ' +\n  'Either use both `myshopifyDomain` and `storefrontApiVersion`, or provide a `customEndpoint`.';\n\n/**\n * Create a GraphQL client using `window.fetch` or the provided `fetchClient`\n */\nexport default function createGqlClient({\n  customEndpoint,\n  fetchClient,\n  myshopifyDomain,\n  storefrontApiVersion,\n  storefrontCheckoutToken\n}: CreateGqlClientParams): GqlClient {\n  const gqlClient: GqlClient = ({ query, variables }) => {\n    let endpoint = customEndpoint;\n\n    if (!endpoint) {\n      if (!myshopifyDomain || !storefrontApiVersion) {\n        throw new Error(missingParametersErrorMessage);\n      }\n      const domain = sanitizeShopifyDomain(myshopifyDomain || '');\n      endpoint = `https://${domain}.myshopify.com/api/${storefrontApiVersion}/graphql`;\n    }\n\n    let fetcher = fetchClient;\n\n    if (!fetcher) {\n      if (typeof window !== 'undefined') {\n        fetcher = window.fetch;\n      } else {\n        throw new Error(fetchClientError);\n      }\n    }\n\n    return fetcher(endpoint, {\n      method: 'POST',\n      headers: {\n        Accept: 'application/json',\n        'Content-Type': 'application/json',\n        'X-Shopify-Storefront-Access-Token': storefrontCheckoutToken\n      },\n      body: JSON.stringify({ query, variables })\n    }).then((res: Response) => res.json());\n  };\n\n  return gqlClient;\n}\n","// courtsey of @manifoldco/gql-zero (https://github.com/manifoldco/gql-zero)\n\ninterface StringCompatible {\n  toString(): string;\n}\n\n/**\n * Tagged template literal to enable syntax highlighting for inline GraphQL queries\n *\n * @example\n * import { gql } from '/path/to/utils';\n *\n * gql`\n *   query {\n *     getBirthdayInfo(user: 'nacelleBot') {\n *       date\n *       astrologySign\n *     }\n *   }\n * `\n */\nexport default function gql(\n  str: TemplateStringsArray,\n  ...values: StringCompatible[]\n): string {\n  return str.reduce((acc, s, i) => `${acc}${s}${values[i] || ''}`, '');\n}\n","import {\n  ShopifyCheckoutUserError,\n  ShopifyError\n} from '../checkout-client.types';\n\nexport interface VerboseErrorParams {\n  caller?: string;\n  message?: string;\n}\n\nexport default function handleShopifyError(\n  errors?: ShopifyCheckoutUserError[] | ShopifyError[],\n  { caller, message }: VerboseErrorParams = {}\n): void {\n  let errorMessage = '';\n\n  if (caller) {\n    errorMessage = `[${caller}] `;\n  }\n\n  errorMessage =\n    errorMessage +\n    (message || 'Shopify Storefront API Errors:') +\n    (errors ? '\\n' + JSON.stringify(errors, null, 2) : '');\n\n  throw new Error(errorMessage);\n}\n","export default function isVerifiedCheckoutId(id: string): boolean {\n  // Shopify CheckoutIds are Base64-encoded urls formatted like:\n  // 'gid://shopify/Checkout/<id>' and therefore must include 'Z2lkOi8vc2hvcGlmeS9DaGVja291dC8'\n  if (!id?.length) {\n    return false;\n  }\n\n  return id.includes('Z2lkOi8vc2hvcGlmeS9DaGVja291dC8') && id !== '';\n}\n","import { Attribute, Metafield } from '../checkout-client.types';\n\nexport interface ReconcileCustomAttributesParams {\n  metafields?: Metafield[];\n}\n\n/**\n * Given either `customAttributes` or `metafields`, return `customAttributes`.\n *\n * If `customAttributes` are provided, `metafields` will be ignored.\n */\nexport default function metafieldsToCustomAttributes({\n  metafields\n}: ReconcileCustomAttributesParams): Attribute[] {\n  if (!Array.isArray(metafields) || !metafields?.length) {\n    return [];\n  }\n\n  const customAttributes: Attribute[] = metafields?.reduce((fields, m) => {\n    if (typeof m.value === 'string') {\n      fields.push({ key: m.key, value: m.value });\n    } else {\n      console.warn(\n        `Omitting custom attribute \"${m.key}\" because it has a non-string value.`\n      );\n    }\n\n    return fields;\n  }, [] as Attribute[]);\n\n  return customAttributes;\n}\n","/**\n * Transforms variant ids to valid PlainText shopify gids\n * If the variant id is a valid gid, that gid will be returned instead.\n * If the variant is a Base64 encoded gid, that gid will be returned\n * @param variantId - the variant id to transform\n * @returns gid - a valid shopify variant gid of the form gid://shopify/ProductVariant/{numeric-id}\n */\nexport default function (variantId: string): string {\n  // if it's already a global id, just return it\n  if (isPlainTextGlobalId(variantId)) {\n    return variantId;\n  }\n\n  if (isNumeric(variantId)) {\n    return idToVariantGid(variantId);\n  }\n\n  const decodedVariantId = decodeBase64Id(variantId);\n\n  if (isPlainTextGlobalId(decodedVariantId)) {\n    return decodedVariantId;\n  }\n  // otherwise it's absolutely not a valid id and we should throw\n  throw Error(`${variantId} is an invalid shopify variant id`);\n}\n\nfunction isPlainTextGlobalId(variantId: string) {\n  return variantId.startsWith('gid://shopify/');\n}\n\nfunction isNumeric(variantId: string) {\n  return !Number.isNaN(Number(variantId));\n}\n\nfunction decodeBase64Id(variantId: string): string {\n  try {\n    // if window undefined, we're in node\n    if (typeof window === 'undefined') {\n      // if the decoded & re-encoded string is the same as the original, decode it. This is b/c Buffer.from won't error on invalid chars\n      if (Buffer.from(variantId, 'base64').toString('base64') === variantId) {\n        return Buffer.from(variantId, 'base64').toString();\n      } else {\n        // if it's not valid base64, just return it\n        return variantId;\n      }\n    } else {\n      // we're in the browser so use browser methods\n      // window.atob will throw if there are invalid chars, so we don't need to be as safe here\n      return window.atob(variantId);\n    }\n  } catch (err) {\n    return variantId;\n  }\n}\n\nfunction idToVariantGid(variantId: string): string {\n  return `gid://shopify/ProductVariant/${variantId}`;\n}\n","import { gql } from '../../utils';\nimport {\n  ShopifyCheckoutUserError,\n  ShopifyCheckoutResponseProperties\n} from '../../checkout-client.types';\n\nexport interface CheckoutCreateData {\n  checkoutCreate: {\n    checkout: ShopifyCheckoutResponseProperties | null;\n    checkoutUserErrors: ShopifyCheckoutUserError[];\n  };\n}\n\nexport const checkoutCreate = gql`\n  mutation checkoutCreate($input: CheckoutCreateInput!) {\n    checkoutCreate(input: $input) {\n      checkout {\n        id\n        webUrl\n      }\n      checkoutUserErrors {\n        code\n        field\n        message\n      }\n    }\n  }\n`;\n\nexport interface CheckoutLineItemsReplaceData {\n  checkoutLineItemsReplace: {\n    checkout: ShopifyCheckoutResponseProperties | null;\n    userErrors: ShopifyCheckoutUserError[];\n  };\n}\n\nexport const checkoutLineItemsReplace = gql`\n  mutation checkoutLineItemsReplace(\n    $lineItems: [CheckoutLineItemInput!]!\n    $checkoutId: ID!\n  ) {\n    checkoutLineItemsReplace(lineItems: $lineItems, checkoutId: $checkoutId) {\n      checkout {\n        id\n        webUrl\n      }\n      userErrors {\n        code\n        field\n        message\n      }\n    }\n  }\n`;\n\nexport interface CheckoutAttributesUpdateData {\n  checkoutAttributesUpdateV2: {\n    checkout: ShopifyCheckoutResponseProperties | null;\n    checkoutUserErrors: ShopifyCheckoutUserError[];\n  };\n}\n\nexport const checkoutAttributesUpdate = gql`\n  mutation checkoutAttributesUpdate(\n    $checkoutId: ID!\n    $input: CheckoutAttributesUpdateV2Input!\n  ) {\n    checkoutAttributesUpdateV2(checkoutId: $checkoutId, input: $input) {\n      checkout {\n        id\n        webUrl\n      }\n      checkoutUserErrors {\n        code\n        field\n        message\n      }\n    }\n  }\n`;\n","import { buildCheckout, handleShopifyError } from '../../utils';\nimport {\n  checkoutAttributesUpdate as checkoutAttributesUpdateMutation,\n  CheckoutAttributesUpdateData\n} from '../../graphql/mutations';\nimport {\n  ShopifyCheckout,\n  Attribute,\n  GqlClient\n} from '../../checkout-client.types';\n\nexport interface CheckoutAttributesUpdateParams {\n  gqlClient: GqlClient;\n  /**\n   * a Shopify checkout ID.\n   */\n  id: string;\n  customAttributes?: Attribute[];\n  note?: string;\n}\n\nexport type CheckoutUpdateVariables = {\n  checkoutId: CheckoutAttributesUpdateParams['id'];\n  input: Pick<CheckoutAttributesUpdateParams, 'customAttributes' | 'note'>;\n};\n\nexport default async function checkoutAttributesUpdate({\n  gqlClient,\n  id,\n  customAttributes,\n  note\n}: CheckoutAttributesUpdateParams): Promise<ShopifyCheckout | void> {\n  const query = checkoutAttributesUpdateMutation;\n  const variables = {\n    checkoutId: id,\n    input: {\n      customAttributes,\n      note\n    }\n  };\n\n  const { data, errors } = await gqlClient<\n    CheckoutUpdateVariables,\n    CheckoutAttributesUpdateData\n  >({ query, variables }).catch((err) => {\n    throw new Error(err);\n  });\n\n  const errs = errors || data?.checkoutAttributesUpdateV2.checkoutUserErrors;\n\n  if (errs?.length) {\n    handleShopifyError(errs, { caller: 'checkoutAttributesUpdate' });\n  }\n\n  if (data?.checkoutAttributesUpdateV2.checkout) {\n    return buildCheckout(data.checkoutAttributesUpdateV2.checkout);\n  }\n}\n","import { buildCheckout, handleShopifyError } from '../../utils';\nimport {\n  checkoutCreate as checkoutCreateMutation,\n  CheckoutCreateData\n} from '../../graphql/mutations';\nimport {\n  Attribute,\n  CheckoutItem,\n  GqlClient,\n  ShopifyCheckout\n} from '../../checkout-client.types';\n\nexport interface CreateCheckoutParams {\n  gqlClient: GqlClient;\n  lineItems: CheckoutItem[];\n  customAttributes?: Attribute[];\n  note?: string;\n  queueToken?: string;\n}\n\nexport type CheckoutCreateVariables = {\n  input: Pick<CreateCheckoutParams, 'customAttributes' | 'lineItems' | 'note'>;\n};\n\nexport default async function createCheckout({\n  gqlClient,\n  lineItems,\n  customAttributes,\n  note,\n  queueToken\n}: CreateCheckoutParams): Promise<ShopifyCheckout | void> {\n  const query = checkoutCreateMutation;\n  const variables = {\n    input: { customAttributes, lineItems, note },\n    queueToken\n  };\n\n  try {\n    const { data, errors } = await gqlClient<\n      CheckoutCreateVariables,\n      CheckoutCreateData\n    >({\n      query,\n      variables\n    }).catch((err) => {\n      throw new Error(err);\n    });\n\n    const errs = errors || data?.checkoutCreate.checkoutUserErrors;\n\n    if (errs?.length) {\n      handleShopifyError(errors, { caller: 'checkoutCreate' });\n    }\n\n    if (data?.checkoutCreate.checkout) {\n      return buildCheckout(data.checkoutCreate.checkout);\n    }\n  } catch (err) {\n    throw new Error(String(err));\n  }\n}\n","import {\n  checkoutLineItemsReplace as checkoutLineItemsReplaceMutation,\n  CheckoutLineItemsReplaceData\n} from '../../graphql/mutations';\nimport { buildCheckout, handleShopifyError } from '../../utils';\nimport {\n  CheckoutItem,\n  ShopifyCheckout,\n  GqlClient\n} from '../../checkout-client.types';\n\nexport interface CheckoutLineItemsReplaceParams {\n  gqlClient: GqlClient;\n  /**\n   * a Shopify checkout ID.\n   */\n  id: string;\n  lineItems: CheckoutItem[];\n}\n\nexport type CheckoutLineItemsReplaceVariables = Pick<\n  CheckoutLineItemsReplaceParams,\n  'lineItems'\n> & { checkoutId: CheckoutLineItemsReplaceParams['id'] };\n\nexport default async function checkoutLineItemsReplace({\n  gqlClient,\n  lineItems,\n  id\n}: CheckoutLineItemsReplaceParams): Promise<ShopifyCheckout | void> {\n  const query = checkoutLineItemsReplaceMutation;\n  const variables = { checkoutId: id, lineItems };\n  const { data, errors } = await gqlClient<\n    CheckoutLineItemsReplaceVariables,\n    CheckoutLineItemsReplaceData\n  >({ query, variables }).catch((err) => {\n    throw new Error(err);\n  });\n\n  const errs = errors || data?.checkoutLineItemsReplace.userErrors;\n\n  if (errs?.length) {\n    handleShopifyError(errs, { caller: 'checkoutLineItemsReplace' });\n  }\n\n  if (data?.checkoutLineItemsReplace.checkout) {\n    return buildCheckout(data.checkoutLineItemsReplace.checkout);\n  }\n}\n","import { gql } from '../../utils';\nimport { GqlStringField } from '../../checkout-client.types';\n\nexport interface CheckoutNode {\n  id: GqlStringField;\n  webUrl: GqlStringField;\n  completedAt: GqlStringField;\n}\n\nexport interface GetCheckoutData {\n  node: CheckoutNode | null;\n}\n\nexport const getCheckout = gql`\n  query getCheckout($id: ID!) {\n    node(id: $id) {\n      ... on Checkout {\n        id\n        webUrl\n        completedAt\n      }\n    }\n  }\n`;\n","import {\n  getCheckout as getCheckoutQuery,\n  GetCheckoutData\n} from '../../graphql/queries';\nimport { handleShopifyError } from '../../utils';\nimport { ShopifyCheckout, GqlClient } from '../../checkout-client.types';\n\nexport interface FindCheckoutParams {\n  gqlClient: GqlClient;\n  /**\n   * a Shopify checkout ID.\n   */\n  id: string;\n}\n\nexport type FindCheckoutVariables = Pick<FindCheckoutParams, 'id'>;\n\nexport default async function findCheckout({\n  gqlClient,\n  id\n}: FindCheckoutParams): Promise<ShopifyCheckout | void> {\n  const query = getCheckoutQuery;\n  const variables = { id };\n\n  const { data, errors } = await gqlClient<\n    FindCheckoutVariables,\n    GetCheckoutData\n  >({ query, variables }).catch((err) => {\n    throw new Error(err);\n  });\n\n  if (errors) {\n    handleShopifyError(errors, { caller: 'findCheckout' });\n  }\n\n  if (!data?.node) {\n    handleShopifyError(undefined, {\n      caller: 'findCheckout',\n      message: 'Checkout response has no data'\n    });\n  } else {\n    const { id, webUrl, completedAt } = data.node;\n\n    return {\n      completed: Boolean(completedAt),\n      id: id || '',\n      url: webUrl || ''\n    };\n  }\n}\n","import {\n  checkoutAttributesUpdate,\n  checkoutLineItemsReplace,\n  checkoutCreate\n} from '../../client/actions';\nimport { isVerifiedCheckoutId } from '../../utils';\nimport { ShopifyCheckout } from '../../checkout-client.types';\nimport { CreateCheckoutParams } from '../../client/actions/checkoutCreate';\nimport { CheckoutAttributesUpdateParams } from '../../client/actions/checkoutAttributesUpdate';\nimport { CheckoutLineItemsReplaceParams } from '../../client/actions/checkoutLineItemsReplace';\n\ntype CheckoutActionIntersection = CreateCheckoutParams &\n  CheckoutAttributesUpdateParams &\n  CheckoutLineItemsReplaceParams;\n\nexport type PutCheckoutParams = Partial<CheckoutActionIntersection> &\n  Pick<CheckoutActionIntersection, 'gqlClient'>;\n\nexport default async function putCheckout({\n  gqlClient,\n  id,\n  lineItems,\n  customAttributes,\n  note,\n  queueToken\n}: PutCheckoutParams): Promise<void | ShopifyCheckout> {\n  let checkout: ShopifyCheckout | void = undefined;\n  const shouldUpdateLineItems = lineItems?.length;\n  const shouldUpdateAttributes = customAttributes?.length || note;\n\n  try {\n    if (id) {\n      if (!isVerifiedCheckoutId(id)) {\n        throw new Error(\n          `Invalid checkout ID. Expected a Base64-encoded Shopify Global ID. Received: ${id}`\n        );\n      }\n\n      const checkoutUpdatePromises: Promise<ShopifyCheckout | void>[] = [];\n\n      // Update line items\n      if (shouldUpdateLineItems) {\n        checkoutUpdatePromises.push(\n          checkoutLineItemsReplace({\n            gqlClient,\n            id,\n            lineItems\n          })\n        );\n      }\n\n      // Update attributes if provided\n      if (shouldUpdateAttributes) {\n        checkoutUpdatePromises.push(\n          checkoutAttributesUpdate({\n            gqlClient,\n            id,\n            customAttributes,\n            note\n          })\n        );\n      }\n\n      await Promise.allSettled(checkoutUpdatePromises).then((settledPromises) =>\n        settledPromises.forEach((p) => {\n          if (p.status === 'fulfilled' && p.value) {\n            // Note that the order of the promises is important here,\n            // since the last-fulfilled promise's value will overwrite\n            // the checkout data.\n            //\n            // This is why `checkoutAttributesUpdate`, which can return an updated\n            // `note` or `customAttributes`, goes after `checkoutLineItemsReplace`,\n            // which doesn't update any properties of the checkout object\n            // (the `checkoutId` remains the same after a checkoutLineItemsReplace`).\n            checkout = {\n              ...(checkout || {}),\n              ...p.value\n            };\n          } else if (p.status === 'rejected') {\n            throw new Error(p.reason);\n          }\n        })\n      );\n    }\n\n    // Create new checkout if checkout does not exist\n    if (typeof checkout === 'undefined' && typeof lineItems !== 'undefined') {\n      checkout = await checkoutCreate({\n        gqlClient,\n        customAttributes,\n        note,\n        lineItems,\n        queueToken\n      });\n    }\n\n    return checkout;\n  } catch (err) {\n    throw new Error(String(err));\n  }\n}\n","import { findCheckout, putCheckout } from '../client/actions';\nimport { FindCheckoutParams } from '../client/actions/findCheckout';\nimport { PutCheckoutParams } from '../client/actions/putCheckout';\nimport {\n  cartItemsToCheckoutItems,\n  createGqlClient,\n  metafieldsToCustomAttributes\n} from '../utils';\nimport { CartItem, Metafield, ShopifyCheckout } from '../checkout-client.types';\n\nexport interface CreateClientParams {\n  storefrontCheckoutToken: string;\n  storefrontApiVersion?: string;\n  myshopifyDomain?: string;\n  customEndpoint?: string;\n  fetchClient?: typeof fetch;\n}\n\nexport type GetCheckoutParams = Pick<FindCheckoutParams, 'id'>;\n\nexport type GetCheckout = (\n  params: GetCheckoutParams\n) => Promise<ShopifyCheckout | void>;\n\nexport type ProcessCheckoutParams = Pick<\n  PutCheckoutParams,\n  'id' | 'note' | 'queueToken'\n> & { cartItems?: CartItem[]; metafields?: Metafield[] };\n\nexport type ProcessCheckout = (\n  params: ProcessCheckoutParams\n) => Promise<void | ShopifyCheckout>;\n\nexport interface CheckoutClient {\n  /**\n   * Retrieve a previously-created Shopify checkout.\n   */\n  get: GetCheckout;\n  /**\n   * Creates a Shopify checkout, or updates an existing Shopify checkout\n   * if a valid `checkoutId` is provided.\n   */\n  process: ProcessCheckout;\n}\n\n/**\n * Create a Shopify checkout client that can:\n * - `get` an existing Shopify checkout\n * - `process` a new Shopify checkout, or update an existing Shopify checkout\n */\nexport default function createShopifyCheckoutClient({\n  storefrontCheckoutToken,\n  myshopifyDomain,\n  storefrontApiVersion,\n  customEndpoint,\n  fetchClient\n}: CreateClientParams): CheckoutClient {\n  const gqlClient = createGqlClient({\n    customEndpoint,\n    fetchClient,\n    myshopifyDomain,\n    storefrontApiVersion,\n    storefrontCheckoutToken\n  });\n\n  /**\n   * Retrieves a previously-created Shopify checkout.\n   */\n  async function getCheckout({\n    id\n  }: GetCheckoutParams): Promise<ShopifyCheckout | void> {\n    return await findCheckout({ gqlClient, id });\n  }\n\n  async function processCheckout({\n    cartItems,\n    id,\n    metafields,\n    note,\n    queueToken\n  }: ProcessCheckoutParams): Promise<ShopifyCheckout | void> {\n    const lineItems = cartItems?.length\n      ? cartItemsToCheckoutItems({ cartItems })\n      : undefined;\n\n    const customAttributes = metafields?.length\n      ? metafieldsToCustomAttributes({ metafields })\n      : undefined;\n\n    return await putCheckout({\n      gqlClient,\n      lineItems,\n      id,\n      customAttributes,\n      note,\n      queueToken\n    });\n  }\n\n  return {\n    get: getCheckout,\n    process: processCheckout\n  };\n}\n"],"names":[],"mappings":"qlBAEsC,CACpC,KACA,UACuC,OAChC,CACL,KACA,IAAK,EACL,UAAW,+ECML,EAAY,EAAwB,SAKnC,kBAJkB,EAA6B,CACpD,WAAY,EAAS,uCCX3B,WAA+B,EAAwB,eAS9C,AARiB,wBACpB,MAAM,cACP,UAFqB,cAGpB,MAAM,MACP,QAJqB,cAKpB,MAAM,KACP,QAEuB,OAiBf,kZASX,iBACA,cACA,kBACA,4GAaM,SAAU,+EAYZ,8BACE,mBAEA,qOClDN,KACG,EACK,OACD,GAAI,OAAO,CAAC,EAAK,EAAG,IAAM,GAAG,IAAM,IAAI,EAAO,IAAM,KAAM,eCdjE,EACA;uDCZ2C,EAAqB,OAG3D,kBAAI,8DACA,cCO0C,CACnD,cAC+C,OAC3C,CAAC,MAAM,QAAQ,IAAe,CAAC,kBAAY,QACtC,GAIgB,gDACA,2JCXrB,EAAoB,SACf,0GAqBmB,oDAQxB,6CAIS,uOC9BF,GAAiB,6rBCc5B,mBACA,SAEA,wBAEc,kbCPd,mBACA,OACA,eAEA,4EAcI,qKAeQ,qOChCZ,OAEA,wBAEc,iCAWV,KAAM,oSC5BC,GAAc,mKCMzB,mBAKM,kBAOF,iGAeA,sSC3BJ,OACA,eAEA,MACA,kEAGI,IACE,oJAiBI,KACA,eAOF,KACqB,KACrB,EAAyB,CACvB,YACA,KACA,mBACA,eAOE,yFAUgB,OACb,EAAE,eAEE,EAAE,SAAW,gBAChB,IAAI,OAAM,EAAE,4EAUtB,YACA,mBACA,OACA,qKCzCN,gBAEA,mFAKE,6EAIA,6FAcA,YACA,KACA,aACA,2BAMM,oFAOJ,sCAGA"}